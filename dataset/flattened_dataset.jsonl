{"description": "Service orchestration pattern combining parallel scatter-gather execution with content enrichment. Aggregates responses from multiple backend services into unified JSON payload using Synapse expressions for transformation.", "reply": "api context=/orchestrate name=ServiceOrchestrationAPI resource methods=POST inSequence scatter-gather parallel-execution=true target=Body result-content-type=JSON aggregation expression=${payload} sequence http.get configKey=UserServiceConn relativePath /users/${payload.userId} headers [] sequence http.get configKey=OrderServiceConn relativePath /orders/${payload.userId} headers [] respond"}
{"description": "API throttling implementation using throttle mediator to limit request rates per client IP address. Enforces maximum 10 requests per minute with policy configuration and error handling for rate limit exceeded scenarios.", "reply": "api context=/throttled name=ThrottledAPI resource methods=GET inSequence throttle id=RateLimitPolicy policy Policy ThrottleAssertion MaximumConcurrentAccess 10 http.get configKey=BackendConn relativePath /resource respond"}
{"description": "Content enrichment pattern using enrich mediator to merge data from external service into existing payload. Performs HTTP GET to retrieve additional customer details and enriches original message body.", "reply": "sequence name=EnrichmentSequence variable name=orderId expression=${payload.orderId} type=STRING http.get configKey=CustomerServiceConn relativePath /customers/${payload.customerId} headers [] variable name=customerData expression=${payload} type=JSON payloadFactory media-type=json format { \"orderId\": \"${vars.orderId}\", \"customer\": ${vars.customerData} }"}
{"description": "Loopback mediator pattern for conditional request routing. Implements decision logic to redirect requests back to API resource start based on authentication status, enabling retry or alternative processing paths.", "reply": "api context=/loopback name=LoopbackAPI resource methods=POST inSequence filter xpath=${exists(headers.Authorization)} then http.post configKey=SecureServiceConn relativePath /process headers [[\"Authorization\", \"${headers.Authorization}\"]] requestBodyType JSON requestBodyJson ${payload} else loopback respond"}
{"description": "Message validation and transformation pipeline using validate mediator with schema validation followed by payloadFactory transformation. Ensures incoming requests conform to XSD schema before processing and converts to canonical format.", "reply": "sequence name=ValidationPipeline validate schema key=gov:/schemas/order-schema.xsd on-fail payloadFactory media-type=json format {\"error\": \"Invalid request format\", \"details\": \"${props.synapse.ERROR_MESSAGE}\"} variable name=HTTP_SC value=400 type=STRING respond payloadFactory media-type=json format { \"orderId\": \"${xpath('//order/id/text()')}', \"amount\": ${xpath('//order/amount/text()')} }"}
{"description": "Database lookup integration pattern using dblookup mediator for data enrichment from MySQL database. Queries customer information based on request parameter and injects results into message flow using Synapse expressions.", "reply": "sequence name=DBLookupSequence dblookup connection pool driver com.mysql.jdbc.Driver url jdbc:mysql://localhost:3306/customerdb user dbuser password dbpass123 statement sql SELECT name, email FROM customers WHERE id = ? parameter expression=${payload.customerId} type=INTEGER result name=customerName column=name result name=customerEmail column=email payloadFactory media-type=json format {\"name\": \"${vars.customerName}\", \"email\": \"${vars.customerEmail}\"}"}
{"description": "Complex scatter-gather orchestration with conditional aggregation and timeout handling. Executes parallel service calls to inventory, pricing, and shipping services with 5-second timeout and minimum response threshold before aggregation.", "reply": "api context=/product-info name=ProductAggregationAPI resource methods=GET uri-template=/{productId} inSequence scatter-gather parallel-execution=true target=Body result-content-type=JSON aggregation expression=${payload} timeout=5000 min-messages=${2} sequence http.get configKey=InventoryConn relativePath /stock/${params.pathParams.productId} headers [] sequence http.get configKey=PricingConn relativePath /price/${params.pathParams.productId} headers [] sequence http.get configKey=ShippingConn relativePath /delivery/${params.pathParams.productId} headers [] respond"}
{"description": "Content-based routing with enrichment and caching using switch mediator for protocol selection. Routes messages to different backend services based on request type, enriches with metadata, and caches frequent responses using Redis connector.", "reply": "api context=/route name=ContentBasedRoutingAPI resource methods=POST inSequence variable name=cacheKey expression=${payload.requestType} type=STRING redis.get configKey=RedisCache key ${vars.cacheKey} filter xpath=${exists(vars.redis_response)} then variable name=payload expression=${vars.redis_response} type=JSON respond else switch source=${payload.requestType} case regex=premium http.post configKey=PremiumServiceConn relativePath /process requestBodyType JSON requestBodyJson ${payload} default http.post configKey=StandardServiceConn relativePath /process requestBodyType JSON requestBodyJson ${payload} redis.put configKey=RedisCache key ${vars.cacheKey} value ${payload} respond"}
{"description": "Transaction management pattern using transaction mediator with database operations. Coordinates atomic database insert and update operations with rollback capability on failure using dbreport mediator for order processing workflow.", "reply": "sequence name=TransactionSequence transaction action=new dbreport connection pool driver com.mysql.jdbc.Driver url jdbc:mysql://localhost:3306/orderdb user dbuser password dbpass123 statement sql INSERT INTO orders (id, customer_id, amount) VALUES (?, ?, ?) parameter expression=${payload.orderId} type=VARCHAR parameter expression=${payload.customerId} type=INTEGER parameter expression=${payload.amount} type=DOUBLE dbreport connection pool driver com.mysql.jdbc.Driver url jdbc:mysql://localhost:3306/orderdb user dbuser password dbpass123 statement sql UPDATE inventory SET quantity = quantity - ? WHERE product_id = ? parameter expression=${payload.quantity} type=INTEGER parameter expression=${payload.productId} type=VARCHAR transaction action=commit"}
{"description": "Foreach mediator pattern for batch processing individual array elements. Iterates through order items collection, validates each item, calls pricing service sequentially, and aggregates results into consolidated response payload.", "reply": "api context=/batch name=BatchProcessingAPI resource methods=POST inSequence variable name=results value=[] type=JSON foreach expression=${payload.items} sequence filter xpath=${payload.quantity > 0} then http.post configKey=PricingServiceConn relativePath /calculate requestBodyType JSON requestBodyJson ${payload} variable name=results expression=${vars.results + payload} type=JSON payloadFactory media-type=json format {\"processedItems\": ${vars.results}} respond"}
{"description": "Advanced error handling with throwError mediator and custom fault sequence. Validates required fields using filter mediator, throws typed errors with dynamic messages, and handles faults with structured error responses and logging.", "reply": "api context=/validate name=ValidationAPI resource methods=POST inSequence filter xpath=${exists(payload.email) and exists(payload.phone)} then http.post configKey=UserServiceConn relativePath /register requestBodyType JSON requestBodyJson ${payload} respond else variable name=errorMsg value=Missing required fields: email or phone type=STRING throwError type=VALIDATION_ERROR errorMessage={${vars.errorMsg}} faultSequence log category=ERROR message Error Code: ${props.synapse.ERROR_CODE}, Message: ${props.synapse.ERROR_MESSAGE} payloadFactory media-type=json format {\"error\": \"${props.synapse.ERROR_CODE}\", \"message\": \"${props.synapse.ERROR_MESSAGE}\"} variable name=HTTP_SC value=400 type=STRING respond"}
{"description": "Multi-level content enrichment with sequential HTTP calls and data merging. Retrieves base user profile, enriches with account details, adds transaction history, and constructs comprehensive customer view using payloadFactory with Synapse expressions.", "reply": "sequence name=MultiEnrichmentSequence variable name=userId expression=${payload.userId} type=STRING http.get configKey=ProfileServiceConn relativePath /profile/${vars.userId} headers [] variable name=profile expression=${payload} type=JSON http.get configKey=AccountServiceConn relativePath /account/${vars.userId} headers [] variable name=account expression=${payload} type=JSON http.get configKey=TransactionServiceConn relativePath /transactions/${vars.userId} headers [] variable name=transactions expression=${payload} type=JSON payloadFactory media-type=json format { \"userId\": \"${vars.userId}\", \"profile\": ${vars.profile}, \"account\": ${vars.account}, \"transactions\": ${vars.transactions} }"}
{"description": "Smart caching pattern with Redis connector implementing cache-aside strategy. Checks cache first, on miss invokes backend service, stores result in Redis with TTL, and handles cache failures gracefully with fallback logic.", "reply": "api context=\"/cached\" name=\"SmartCacheAPI\" xmlns=\"http://ws.apache.org/ns/synapse\" resource methods=\"GET\" uri-template=\"/product/{id}\" inSequence variable name=\"cacheKey\" expression=\"${\"product:\" params.pathParams.id}\" type=\"STRING\" redis.get configKey=\"RedisCache\" key ${vars.cacheKey} filter xpath=\"${exists(vars.redis_response)}\" then log category=\"INFO\" message Cache hit for ${vars.cacheKey} variable name=\"payload\" expression=\"${vars.redis_response}\" type=\"JSON\" respond else log category=\"INFO\" message Cache miss for ${vars.cacheKey} http.get configKey=\"ProductServiceConn\" relativePath /products/${params.pathParams.id} headers [] redis.put configKey=\"RedisCache\" key ${vars.cacheKey} value ${payload} ttl 3600 respond"}
{"description": "Conditional scatter-gather with dynamic service selection based on request attributes. Executes parallel calls only to required services determined by user tier, aggregates results with timeout, and transforms response using filter conditions.", "reply": "api context=/dynamic name=DynamicOrchestrationAPI resource methods=POST inSequence variable name=userTier expression=${payload.tier} type=STRING scatter-gather parallel-execution=true target=Body result-content-type=JSON aggregation expression=${payload} timeout=8000 sequence http.get configKey=BasicServiceConn relativePath /data headers [] sequence filter xpath=${vars.userTier == 'premium'} then http.get configKey=PremiumServiceConn relativePath /analytics headers [] else payloadFactory media-type=json format {\"analytics\": null} payloadFactory media-type=json format {\"tier\": \"${vars.userTier}\", \"data\": ${payload}} respond"}
{"description": "Enterprise integration pattern combining message routing, transformation, and persistence. Implements content-based router with switch mediator, enriches messages from database lookup, transforms using XSLT, and logs to database using dbreport.", "reply": "api context=/integration name=EnterprisePatternAPI resource methods=POST inSequence dblookup connection pool driver com.mysql.jdbc.Driver url jdbc:mysql://localhost:3306/configdb user dbuser password dbpass123 statement sql SELECT routing_key FROM config WHERE client_id = ? parameter expression=${payload.clientId} type=VARCHAR result name=routingKey column=routing_key switch source=${vars.routingKey} case regex=priority http.post configKey=PriorityQueueConn relativePath /enqueue requestBodyType JSON requestBodyJson ${payload} default http.post configKey=StandardQueueConn relativePath /enqueue requestBodyType JSON requestBodyJson ${payload} dbreport connection pool driver com.mysql.jdbc.Driver url jdbc:mysql://localhost:3306/auditdb user dbuser password dbpass123 statement sql INSERT INTO audit_log (client_id, routing_key, timestamp) VALUES (?, ?, NOW()) parameter expression=${payload.clientId} type=VARCHAR parameter expression=${vars.routingKey} type=VARCHAR respond"}
{"description": "Filter mediator implementation for content-based routing that validates HTTP method from synapse properties and routes GET requests to a specific sequence while dropping other request types. Uses Synapse Expression for property access.", "reply": "sequence name=MethodFilterSequence filter xpath=${props.synapse.REST_METHOD == 'GET'} then sequence key=GetRequestSequence else drop"}
{"description": "Switch mediator configuration for routing messages based on payload category field using Synapse Expressions. Routes to different HTTP endpoints depending on book category value with default fallback endpoint.", "reply": "sequence name=CategoryRouter switch source=${payload.book.category} case regex=fiction http.get configKey=FictionServiceConn relativePath /books headers [] case regex=science http.get configKey=ScienceServiceConn relativePath /books headers [] default http.get configKey=DefaultServiceConn relativePath /books headers []"}
{"description": "Filter mediator with JSONPath-style filtering using Synapse Expressions to validate product price threshold. Routes items under budget to processing sequence, logs expensive items separately.", "reply": "sequence name=PriceFilter filter xpath=${payload.product.price < 100} then log category=INFO message Affordable product: ${payload.product.name} sequence key=ProcessOrderSequence else log category=WARN message Expensive product: ${payload.product.price}"}
{"description": "Conditional routing based on HTTP Content-Type header evaluation. Filter mediator checks header value and routes JSON requests to REST endpoint, XML requests to SOAP endpoint using HTTP connector.", "reply": "sequence name=ContentTypeRouter filter xpath=${headers['Content-Type'] == 'application/json'} then http.post configKey=RestServiceConn relativePath /api/data headers [] requestBodyType JSON requestBodyJson ${payload} else http.post configKey=SoapServiceConn relativePath /service headers [] requestBodyType XML requestBodyXml {${xpath('$body/node()')}}"}
{"description": "Switch mediator implementation for multi-condition routing based on user role variable. Routes admin users to management endpoint, regular users to standard endpoint, guests to public endpoint with authentication headers.", "reply": "sequence name=RoleBasedRouter variable name=userRole expression=${payload.user.role} type=STRING switch source=${vars.userRole} case regex=admin http.post configKey=AdminServiceConn relativePath /management headers [[\"Authorization\",\"Bearer admin123\"]] requestBodyType JSON requestBodyJson ${payload} case regex=user http.post configKey=UserServiceConn relativePath /standard headers [[\"Authorization\",\"Bearer user456\"]] requestBodyType JSON requestBodyJson ${payload} default http.get configKey=PublicServiceConn relativePath /public headers []"}
{"description": "Filter mediator validating array length from payload using Synapse Expression length function. Routes orders with items to fulfillment, rejects empty orders with error logging and throwError mediator.", "reply": "sequence name=OrderValidator filter xpath=${length(payload.order.items) > 0} then log category=INFO message Valid order with ${length(payload.order.items)} items sequence key=FulfillmentSequence else log category=ERROR message Empty order rejected throwError type=VALIDATION_ERROR errorMessage=Order must contain at least one item"}
{"description": "Switch mediator for geographic routing based on country code in payload. Routes North American traffic to US datacenter, European traffic to EU datacenter, Asian traffic to APAC datacenter using region-specific connectors.", "reply": "sequence name=GeoRouter switch source=${payload.customer.country} case regex=US|CA|MX http.post configKey=USDatacenterConn relativePath /api/process headers [] requestBodyType JSON requestBodyJson ${payload} case regex=GB|DE|FR|IT|ES http.post configKey=EUDatacenterConn relativePath /api/process headers [] requestBodyType JSON requestBodyJson ${payload} case regex=CN|JP|IN|SG http.post configKey=APACDatacenterConn relativePath /api/process headers [] requestBodyType JSON requestBodyJson ${payload} default throwError type=ROUTING_ERROR errorMessage=Unsupported country code"}
{"description": "Nested filter mediators for multi-level conditional validation. First validates customer type, then checks account status, routes active premium customers to priority processing, others to standard queue.", "reply": "sequence name=CustomerTypeValidator filter xpath=${payload.customer.type == 'premium'} then filter xpath=${payload.customer.status == 'active'} then log category=INFO message Premium active customer routed to priority http.post configKey=PriorityQueueConn relativePath /priority headers [] requestBodyType JSON requestBodyJson ${payload} else sequence key=StandardQueueSequence else sequence key=StandardQueueSequence"}
{"description": "Filter mediator using Synapse Expression exists function to validate required field presence. Checks if customer ID exists in payload, processes valid requests, throws validation error for missing data.", "reply": "sequence name=RequiredFieldValidator filter xpath=${exists(payload.customerId)} then log category=INFO message Processing request for customer ${payload.customerId} http.post configKey=CustomerServiceConn relativePath /customer headers [] requestBodyType JSON requestBodyJson ${payload} else throwError type=VALIDATION_ERROR errorMessage=Customer ID is required"}
{"description": "Switch mediator for payment method routing with ternary operator in Synapse Expression. Routes credit card to payment gateway, PayPal to external API, bank transfer to internal processing based on payment type field.", "reply": "sequence name=PaymentRouter variable name=paymentMethod expression=${payload.payment.method} type=STRING switch source=${vars.paymentMethod} case regex=creditcard http.post configKey=PaymentGatewayConn relativePath /process headers [[\"Content-Type\",\"application/json\"]] requestBodyType JSON requestBodyJson ${payload} case regex=paypal http.post configKey=PayPalAPIConn relativePath /payment headers [] requestBodyType JSON requestBodyJson ${payload} case regex=banktransfer sequence key=BankTransferSequence default throwError type=PAYMENT_ERROR errorMessage=Invalid payment method"}
{"description": "Filter mediator with arithmetic comparison in Synapse Expression for inventory threshold validation. Checks stock quantity against minimum level, triggers reorder sequence or normal fulfillment based on availability.", "reply": "sequence name=InventoryThresholdValidator variable name=stockLevel expression=${payload.product.stockQuantity} type=INTEGER variable name=minThreshold expression=${payload.product.minStock} type=INTEGER filter xpath=${vars.stockLevel < vars.minThreshold} then log category=WARN message Low stock alert: ${vars.stockLevel} units remaining sequence key=ReorderSequence else log category=INFO message Sufficient stock available sequence key=FulfillmentSequence"}
{"description": "Switch mediator implementing priority-based message routing using numeric range matching. Routes urgent priority to express queue, high to priority queue, normal to standard queue with corresponding SLA configurations.", "reply": "sequence name=PriorityRouter variable name=priority expression=${payload.message.priority} type=INTEGER switch source=${vars.priority} case regex=[9]|[1][0] log category=INFO message Urgent priority: routing to express queue http.post configKey=ExpressQueueConn relativePath /urgent headers [[\"SLA\",\"express\"]] requestBodyType JSON requestBodyJson ${payload} case regex=[6-8] http.post configKey=PriorityQueueConn relativePath /priority headers [[\"SLA\",\"high\"]] requestBodyType JSON requestBodyJson ${payload} default http.post configKey=StandardQueueConn relativePath /standard headers [[\"SLA\",\"normal\"]] requestBodyType JSON requestBodyJson ${payload}"}
{"description": "Filter mediator with logical AND operation combining multiple conditions in Synapse Expression. Validates age eligibility and account verification status before routing to service, rejects invalid combinations.", "reply": "sequence name=EligibilityValidator filter xpath=${payload.user.age >= 18 and payload.user.verified == true} then log category=INFO message User eligible: ${payload.user.id} http.post configKey=ServiceAccessConn relativePath /access headers [] requestBodyType JSON requestBodyJson ${payload} else log category=WARN message User not eligible throwError type=ELIGIBILITY_ERROR errorMessage=User must be 18+ and verified"}
{"description": "Switch mediator for environment-based routing using configuration value from synapse properties. Routes to development, staging, or production endpoints based on deployment environment variable with connection pooling.", "reply": "sequence name=EnvironmentRouter variable name=environment expression=${configs.deployment_env} type=STRING switch source=${vars.environment} case regex=development http.post configKey=DevServiceConn relativePath /api/endpoint headers [[\"X-Environment\",\"dev\"]] requestBodyType JSON requestBodyJson ${payload} case regex=staging http.post configKey=StagingServiceConn relativePath /api/endpoint headers [[\"X-Environment\",\"stage\"]] requestBodyType JSON requestBodyJson ${payload} case regex=production http.post configKey=ProdServiceConn relativePath /api/endpoint headers [[\"X-Environment\",\"prod\"]] requestBodyType JSON requestBodyJson ${payload} default throwError type=CONFIG_ERROR errorMessage=Invalid environment configuration"}
{"description": "Filter mediator using JSONPath-style filtering with Synapse Expression to find qualifying items. Filters products by price range and category, routes matching results to promotional service, empty results to standard catalog.", "reply": "sequence name=ProductFilter variable name=filteredProducts expression=${payload.products[?(@.price < 50 and @.category == 'electronics')]} type=JSON filter xpath=${length(vars.filteredProducts) > 0} then log category=INFO message Found ${length(vars.filteredProducts)} qualifying products payloadFactory media-type=json format {\"promotionalItems\": ${vars.filteredProducts}} http.post configKey=PromoServiceConn relativePath /promotion headers [] requestBodyType JSON requestBodyJson ${payload} else sequence key=StandardCatalogSequence"}
{"description": "Complex switch mediator for order status workflow routing with enrichment. Evaluates order status, enriches with timestamp, routes pending orders to payment, processing to warehouse, completed to archive with status-specific headers.", "reply": "sequence name=OrderStatusRouter variable name=orderStatus expression=${payload.order.status} type=STRING variable name=timestamp expression=${now()} type=STRING enrich source type=inline clone=true timestamp ${vars.timestamp} target type=property property=ROUTING_TIMESTAMP switch source=${vars.orderStatus} case regex=pending log category=INFO message Routing pending order ${payload.order.id} to payment http.post configKey=PaymentServiceConn relativePath /process headers [[\"Order-Status\",\"pending\"],[\"Timestamp\",\"${vars.timestamp}\"]] requestBodyType JSON requestBodyJson ${payload} case regex=processing http.post configKey=WarehouseServiceConn relativePath /fulfill headers [[\"Order-Status\",\"processing\"]] requestBodyType JSON requestBodyJson ${payload} case regex=completed http.post configKey=ArchiveServiceConn relativePath /archive headers [] requestBodyType JSON requestBodyJson ${payload} default throwError type=STATUS_ERROR errorMessage=Invalid order status"}
{"description": "Filter mediator with type checking using isNumber function in Synapse Expression. Validates numeric transaction amount, converts string to integer if needed, routes valid transactions to processing, rejects invalid formats with error.", "reply": "sequence name=TransactionValidator variable name=amount expression=${payload.transaction.amount} type=STRING filter xpath=${isNumber(vars.amount)} then variable name=amountInt expression=${integer(vars.amount)} type=INTEGER filter xpath=${vars.amountInt > 0} then log category=INFO message Valid transaction amount: ${vars.amountInt} http.post configKey=TransactionProcessorConn relativePath /process headers [] requestBodyType JSON requestBodyJson ${payload} else throwError type=AMOUNT_ERROR errorMessage=Amount must be positive else throwError type=TYPE_ERROR errorMessage=Invalid amount format"}
{"description": "Switch mediator implementing API version routing based on Accept header evaluation. Routes v1 requests to legacy endpoint, v2 to current service, v3 to beta endpoint with version-specific transformations and headers.", "reply": "sequence name=APIVersionRouter variable name=apiVersion expression=${headers['Accept']} type=STRING switch source=${vars.apiVersion} case regex=.*v1.* log category=INFO message Routing to legacy v1 API http.post configKey=LegacyAPIConn relativePath /v1/resource headers [[\"API-Version\",\"1.0\"]] requestBodyType JSON requestBodyJson ${payload} case regex=.*v2.* http.post configKey=CurrentAPIConn relativePath /v2/resource headers [[\"API-Version\",\"2.0\"]] requestBodyType JSON requestBodyJson ${payload} case regex=.*v3.* log category=WARN message Beta API v3 accessed http.post configKey=BetaAPIConn relativePath /v3/resource headers [[\"API-Version\",\"3.0-beta\"]] requestBodyType JSON requestBodyJson ${payload} default throwError type=VERSION_ERROR errorMessage=Unsupported API version"}
{"description": "Filter mediator with complex boolean logic combining OR and AND operations. Validates subscription tier and feature access, routes premium or trial users with specific feature flags to advanced service endpoint, others to basic tier.", "reply": "sequence name=FeatureAccessValidator variable name=tier expression=${payload.user.subscription.tier} type=STRING variable name=hasFeature expression=${payload.user.features.advanced} type=BOOLEAN filter xpath=${(vars.tier == 'premium' or vars.tier == 'trial') and vars.hasFeature == true} then log category=INFO message Advanced feature access granted for ${payload.user.id} http.post configKey=AdvancedServiceConn relativePath /advanced headers [[\"Subscription-Tier\",\"${vars.tier}\"],[\"Feature-Access\",\"advanced\"]] requestBodyType JSON requestBodyJson ${payload} else log category=INFO message Routing to basic tier service http.post configKey=BasicServiceConn relativePath /basic headers [] requestBodyType JSON requestBodyJson ${payload}"}
{"description": "Multi-level switch mediator for complex business rule routing with fallback logic. Primary switch on customer segment, nested switch on transaction type, includes enrichment and variable manipulation for audit trail with dynamic endpoint selection.", "reply": "sequence name=BusinessRuleRouter variable name=segment expression=${payload.customer.segment} type=STRING variable name=txnType expression=${payload.transaction.type} type=STRING variable name=auditId expression=${payload.transaction.id} type=STRING switch source=${vars.segment} case regex=enterprise switch source=${vars.txnType} case regex=bulk log category=INFO message Enterprise bulk transaction ${vars.auditId} http.post configKey=EnterpriseBulkConn relativePath /bulk headers [[\"Segment\",\"enterprise\"],[\"Audit-ID\",\"${vars.auditId}\"]] requestBodyType JSON requestBodyJson ${payload} default http.post configKey=EnterpriseStandardConn relativePath /standard headers [[\"Segment\",\"enterprise\"]] requestBodyType JSON requestBodyJson ${payload} case regex=retail http.post configKey=RetailServiceConn relativePath /retail headers [[\"Segment\",\"retail\"]] requestBodyType JSON requestBodyJson ${payload} default throwError type=SEGMENT_ERROR errorMessage=Unknown customer segment"}
{"description": "Salesforce connector integration to create a new account record with account name and industry fields using OAuth authentication and storing the created account ID in a variable for downstream processing", "reply": "localEntry key=SalesforceConfig salesforce.init name SalesforceConn connectionType init clientId 3MVG9LBJLAx8Z.8Z.8Z clientSecret 1234567890123456789 accessToken 00D50000000IZ3Z!AQwAQH apiVersion v48.0 refreshToken 5Aep861TSESvWeug apiUrl https://login.salesforce.com"}
{"description": "Gmail connector operation to send an email with dynamic recipient, subject, and body content retrieved from payload variables using basic authentication and content-type headers", "reply": "api context=/gmail name=SendEmailAPI resource methods=POST uri-template=/send inSequence gmail.sendMail configKey=GmailConfig to ${payload.recipient} subject ${payload.subject} messageBody ${payload.body} contentType text/html respond"}
{"description": "Slack connector integration to post a message to a specific channel using webhook URL with formatted message text and username customization for notification delivery", "reply": "api context=/slack name=SlackNotificationAPI resource methods=POST uri-template=/notify inSequence slack.postMessage configKey=SlackConfig channel #general text ${payload.message} username IntegrationBot iconEmoji :robot_face: respond"}
{"description": "AWS S3 connector configuration to upload a file object to a specified bucket with ACL permissions and metadata tags using access key and secret key authentication mechanism", "reply": "localEntry key=AWSS3Config amazons3.init name S3Connection awsAccessKeyId AKIAIOSFODNN7EXAMPLE awsSecretAccessKey wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY region us-east-1 connectionType amazons3"}
{"description": "File connector operation to read a file from local file system path, process the content, and move the file to an archive directory with timestamp appended to filename", "reply": "api context=/file name=FileProcessingAPI resource methods=GET uri-template=/process inSequence file.read configKey=FileConfig source /home/data/input/data.json variable name=fileContent expression=${payload} type=STRING file.move configKey=FileConfig source /home/data/input/data.json destination /home/data/archive/data_${now()}.json respond"}
{"description": "Google Drive connector integration to create a new folder in the root directory with specified folder name and permissions using OAuth2 service account authentication", "reply": "api context=/gdrive name=CreateFolderAPI resource methods=POST uri-template=/folder inSequence googledrive.createFolder configKey=GDriveConfig folderName ${payload.folderName} parentId root variable name=folderId expression=${payload.id} type=STRING respond"}
{"description": "Salesforce connector query operation to retrieve account records filtered by industry using SOQL query with field selection, result iteration using foreach mediator, and enriching response with transformed data structure for API response", "reply": "api context=/salesforce name=QueryAccountsAPI resource methods=GET uri-template=/accounts/{industry} inSequence salesforce.query configKey=SalesforceConfig queryString SELECT Id, Name, Industry, AnnualRevenue FROM Account WHERE Industry='${params.pathParams.industry}' variable name=accountList expression=${payload.records} type=JSON payloadFactory media-type=json format {\"totalRecords\":${length(vars.accountList)},\"accounts\":${vars.accountList}} respond"}
{"description": "Azure Blob Storage connector operation to download blob content from container with retry mechanism using shared access signature authentication and storing blob metadata in variables for logging purposes", "reply": "api context=/azure name=DownloadBlobAPI resource methods=GET uri-template=/blob/{containerName}/{blobName} inSequence azureblob.downloadBlob configKey=AzureBlobConfig containerName ${params.pathParams.containerName} blobName ${params.pathParams.blobName} variable name=blobContent expression=${payload} type=STRING log category=INFO message Downloaded blob: ${params.pathParams.blobName} respond"}
{"description": "Gmail connector with list messages operation to retrieve emails from inbox with query filters, label filters, and pagination parameters, then process results using filter mediator to extract unread messages", "reply": "api context=/gmail name=ListEmailsAPI resource methods=GET uri-template=/messages inSequence gmail.listMessages configKey=GmailConfig query is:unread labelIds INBOX maxResults 50 variable name=messages expression=${payload.messages} type=JSON filter xpath=${length(vars.messages) > 0} then log category=INFO message Found ${length(vars.messages)} unread messages respond"}
{"description": "Slack connector integration to retrieve channel history messages with timestamp filters and pagination using bot token authentication, then format response payload with message count and channel details", "reply": "api context=/slack name=ChannelHistoryAPI resource methods=GET uri-template=/history/{channelId} inSequence slack.conversationsHistory configKey=SlackConfig channel ${params.pathParams.channelId} limit 100 variable name=messageList expression=${payload.messages} type=JSON payloadFactory media-type=json format {\"channelId\":\"${params.pathParams.channelId}\",\"messageCount\":${length(vars.messageList)},\"messages\":${vars.messageList}} respond"}
{"description": "AWS S3 connector to list objects in bucket with prefix filtering and delimiter parameters, iterate through results using foreach mediator, and store object keys in variable array for batch processing", "reply": "api context=/s3 name=ListObjectsAPI resource methods=GET uri-template=/list/{bucketName} inSequence amazons3.listObjects configKey=AWSS3Config bucketName ${params.pathParams.bucketName} prefix data/ maxKeys 1000 variable name=objectKeys expression=${payload.Contents[*].Key} type=JSON log category=INFO message Listed ${length(vars.objectKeys)} objects in bucket respond"}
{"description": "File connector operation to write dynamic JSON payload content to a file with append mode enabled, create directory if not exists, and set file permissions for secure access control", "reply": "api context=/file name=WriteFileAPI resource methods=POST uri-template=/write inSequence variable name=fileName expression=${payload.fileName} type=STRING variable name=content expression=${payload.content} type=STRING file.write configKey=FileConfig destination /home/data/output/${vars.fileName} content ${vars.content} appendMode true createDirectory true log category=INFO message File written successfully: ${vars.fileName} respond"}
{"description": "Google Drive connector to upload file with multipart form data, set file metadata including title and description, share file with specific email addresses, and return shareable link in response payload", "reply": "api context=/gdrive name=UploadFileAPI resource methods=POST uri-template=/upload inSequence googledrive.uploadFile configKey=GDriveConfig fileName ${payload.fileName} fileContent ${payload.fileContent} mimeType application/json folderId ${payload.folderId} variable name=fileId expression=${payload.id} type=STRING googledrive.shareFile configKey=GDriveConfig fileId ${vars.fileId} emailAddress ${payload.shareWith} role reader respond"}
{"description": "Salesforce connector update operation to modify existing account records with new field values using record ID from payload, validate response status, and log success or failure with error handling in fault sequence", "reply": "api context=/salesforce name=UpdateAccountAPI resource methods=PUT uri-template=/account/{accountId} inSequence salesforce.update configKey=SalesforceConfig sObjectType Account Id ${params.pathParams.accountId} fieldsToUpdate ${payload.fields} filter xpath=${payload.success == true} then log category=INFO message Account updated successfully: ${params.pathParams.accountId} respond faultSequence log category=ERROR message Update failed: ${props.synapse.ERROR_MESSAGE} drop"}
{"description": "Azure Blob Storage connector to upload JSON content to blob with container creation if not exists, set blob metadata tags for classification, and configure public access level with content encoding", "reply": "api context=/azure name=UploadBlobAPI resource methods=POST uri-template=/upload inSequence variable name=containerName expression=${payload.container} type=STRING variable name=blobName expression=${payload.blobName} type=STRING variable name=blobContent expression=${payload.content} type=STRING azureblob.uploadBlob configKey=AzureBlobConfig containerName ${vars.containerName} blobName ${vars.blobName} blobContent ${vars.blobContent} contentType application/json log category=INFO message Blob uploaded: ${vars.blobName} respond"}
{"description": "Slack connector to create a new channel with specified name and description, invite members to channel using user IDs array, post welcome message, and archive old channel using scatter-gather pattern", "reply": "api context=/slack name=ManageChannelAPI resource methods=POST uri-template=/channel/create inSequence slack.createChannel configKey=SlackConfig channelName ${payload.channelName} isPrivate false variable name=channelId expression=${payload.channel.id} type=STRING slack.inviteToChannel configKey=SlackConfig channel ${vars.channelId} users ${payload.userIds} slack.postMessage configKey=SlackConfig channel ${vars.channelId} text Welcome to the new channel! respond"}
{"description": "Gmail connector to retrieve specific email message by ID, extract attachments with size filtering, decode base64 attachment content, and save attachments to file system using file connector with error handling", "reply": "api context=/gmail name=ProcessAttachmentsAPI resource methods=GET uri-template=/message/{messageId}/attachments inSequence gmail.readMail configKey=GmailConfig messageId ${params.pathParams.messageId} variable name=attachments expression=${payload.attachments} type=JSON foreach expression=${vars.attachments} sequence variable name=attachmentData expression=${payload.data} type=STRING variable name=fileName expression=${payload.filename} type=STRING file.write configKey=FileConfig destination /home/attachments/${vars.fileName} content ${base64Decode(vars.attachmentData)} respond faultSequence log category=ERROR message Attachment processing failed drop"}
{"description": "AWS S3 connector to copy object from source bucket to destination bucket with metadata preservation, delete source object after successful copy, and validate copy operation using conditional filter mediator", "reply": "api context=/s3 name=CopyObjectAPI resource methods=POST uri-template=/copy inSequence amazons3.copyObject configKey=AWSS3Config sourceBucketName ${payload.sourceBucket} sourceKey ${payload.sourceKey} destinationBucketName ${payload.destBucket} destinationKey ${payload.destKey} variable name=copySuccess expression=${exists(payload.CopyObjectResult)} type=BOOLEAN filter xpath=${vars.copySuccess == true} then amazons3.deleteObject configKey=AWSS3Config bucketName ${payload.sourceBucket} objectKey ${payload.sourceKey} log category=INFO message Object copied and source deleted respond"}
{"description": "File connector to monitor directory for new files using polling mechanism, read file content when detected, validate JSON schema using validate mediator, process valid files through HTTP connector to external API, and move processed files", "reply": "sequence name=FileMonitorSequence file.read configKey=FileConfig source /home/data/incoming/data.json variable name=fileContent expression=${payload} type=JSON filter xpath=${exists(vars.fileContent.orderId)} then http.post configKey=OrderAPIConfig relativePath /orders headers [[\"Content-Type\",\"application/json\"]] requestBodyType JSON requestBodyJson ${vars.fileContent} file.move configKey=FileConfig source /home/data/incoming/data.json destination /home/data/processed/data_${now()}.json log category=INFO message File processed successfully else throwError type=VALIDATION_ERROR errorMessage=Invalid file format"}
{"description": "Salesforce connector with bulk API operation to insert multiple records from JSON array payload, monitor bulk job status with polling, retrieve batch results, and aggregate success and failure counts with enrich mediator for reporting", "reply": "api context=/salesforce name=BulkInsertAPI resource methods=POST uri-template=/bulk/insert inSequence salesforce.createBulkJob configKey=SalesforceConfig operation insert sObject Account contentType JSON variable name=jobId expression=${payload.id} type=STRING salesforce.addBatch configKey=SalesforceConfig jobId ${vars.jobId} records ${payload.records} variable name=batchId expression=${payload.id} type=STRING salesforce.closeBulkJob configKey=SalesforceConfig jobId ${vars.jobId} salesforce.getBatchResults configKey=SalesforceConfig jobId ${vars.jobId} batchId ${vars.batchId} payloadFactory media-type=json format {\"jobId\":\"${vars.jobId}\",\"status\":\"${payload.state}\",\"recordsProcessed\":${payload.numberRecordsProcessed}} respond"}
{"description": "Data service configuration exposing MySQL employee database as REST API with GET operation to retrieve employee details by ID using query parameter mapping and JSON output format", "reply": "data name=EmployeeDataService serviceNamespace=http://ws.wso2.org/dataservice config id=MySQLConnection property name=driverClassName com.mysql.jdbc.Driver property name=url jdbc:mysql://localhost:3306/employeedb property name=username dbuser property name=password dbpass123 query id=getEmployeeById useConfig=MySQLConnection sql SELECT emp_id, emp_name, department, salary FROM employees WHERE emp_id=? param name=empId sqlType=INTEGER result element=Employee rowName=Record element column=emp_id name=EmployeeID xsdType=integer element column=emp_name name=Name xsdType=string element column=department name=Department xsdType=string element column=salary name=Salary xsdType=double operation name=getEmployee call-query href=getEmployeeById with-param name=empId query-param=empId"}
{"description": "Simple data service exposing CSV file containing product inventory as SOAP service with single query operation to fetch all products with column-to-element mappings", "reply": "data name=ProductInventoryService serviceNamespace=http://ws.wso2.org/dataservice config id=CSVDataSource property name=csv_datasource /home/user/data/products.csv property name=csv_columnseperator , property name=csv_hasheader true query id=getAllProducts useConfig=CSVDataSource result element=Products rowName=Product element column=product_id name=ID xsdType=string element column=name name=ProductName xsdType=string element column=stock name=StockQuantity xsdType=integer operation name=listProducts call-query href=getAllProducts"}
{"description": "Data service with PostgreSQL datasource providing CRUD operations including INSERT employee record with input mappings for name, department, and salary fields using SQL parameters", "reply": "data name=EmployeeCRUDService serviceNamespace=http://ws.wso2.org/dataservice config id=PostgresDB property name=driverClassName org.postgresql.Driver property name=url jdbc:postgresql://localhost:5432/hrdb property name=username postgres property name=password pgpass456 query id=insertEmployee useConfig=PostgresDB sql INSERT INTO employees (emp_name, department, salary) VALUES (?, ?, ?) param name=name sqlType=STRING param name=dept sqlType=STRING param name=sal sqlType=DOUBLE operation name=addEmployee call-query href=insertEmployee with-param name=name query-param=name with-param name=dept query-param=dept with-param name=sal query-param=sal"}
{"description": "Data service exposing Excel spreadsheet with customer data as REST API including query with filtering by customer status and nested result elements for address information", "reply": "data name=CustomerDataService serviceNamespace=http://ws.wso2.org/dataservice config id=ExcelDataSource property name=excel_datasource /home/user/data/customers.xlsx query id=getActiveCustomers useConfig=ExcelDataSource excel workbookname Customers hasheader true startingrow 2 maxrowcount -1 result element=Customers rowName=Customer element column=customer_id name=ID xsdType=string element column=name name=CustomerName xsdType=string element column=city name=City xsdType=string element column=status name=Status xsdType=string operation name=listActiveCustomers call-query href=getActiveCustomers"}
{"description": "Basic data service configuration with Oracle database connection pool settings exposing single SELECT query to retrieve order summary by order ID with result grouping", "reply": "data name=OrderService serviceNamespace=http://ws.wso2.org/dataservice config id=OracleDB property name=driverClassName oracle.jdbc.driver.OracleDriver property name=url jdbc:oracle:thin:@localhost:1521:orcl property name=username orderadmin property name=password oracle789 property name=maxActive 50 property name=maxIdle 20 query id=getOrderSummary useConfig=OracleDB sql SELECT order_id, customer_name, total_amount, order_date FROM orders WHERE order_id=? param name=orderId sqlType=INTEGER result element=Order rowName=OrderInfo element column=order_id name=OrderID xsdType=integer element column=customer_name name=Customer xsdType=string element column=total_amount name=Total xsdType=double operation name=getOrder call-query href=getOrderSummary with-param name=orderId query-param=orderId"}
{"description": "Data service with SQL Server datasource implementing UPDATE operation to modify product price by product code with input validation and transaction support for data consistency", "reply": "data name=ProductUpdateService enableBatchRequests=true serviceNamespace=http://ws.wso2.org/dataservice config id=SQLServerDB property name=driverClassName com.microsoft.sqlserver.jdbc.SQLServerDriver property name=url jdbc:sqlserver://localhost:1433;databaseName=productdb property name=username sqluser property name=password sqlpass321 query id=updateProductPrice useConfig=SQLServerDB sql UPDATE products SET price=?, updated_date=GETDATE() WHERE product_code=? param name=newPrice sqlType=DOUBLE param name=productCode sqlType=STRING operation name=updatePrice call-query href=updateProductPrice with-param name=newPrice query-param=price with-param name=productCode query-param=code"}
{"description": "Data service exposing Google Sheets spreadsheet as REST API with authentication, retrieving sales data with aggregated columns and custom result formatting for JSON response", "reply": "data name=SalesReportService serviceNamespace=http://ws.wso2.org/dataservice config id=GoogleSheetSource property name=gspread_datasource https://docs.google.com/spreadsheets/d/1ABC123/edit property name=gspread_visibility private property name=gspread_clientid client123.apps.googleusercontent.com property name=gspread_clientsecret secretkey456 query id=getMonthlySales useConfig=GoogleSheetSource gspread worksheetnumber 1 hasheader true startingrow 1 result element=SalesData rowName=SalesRecord element column=month name=Month xsdType=string element column=revenue name=TotalRevenue xsdType=double element column=units name=UnitsSold xsdType=integer operation name=getSalesReport call-query href=getMonthlySales"}
{"description": "Data service with MySQL connection implementing DELETE operation to remove inactive users by user ID with cascading deletions and query parameter binding for secure execution", "reply": "data name=UserManagementService serviceNamespace=http://ws.wso2.org/dataservice config id=MySQLUserDB property name=driverClassName com.mysql.jdbc.Driver property name=url jdbc:mysql://localhost:3306/userdb property name=username admin property name=password adminpass query id=deleteInactiveUser useConfig=MySQLUserDB sql DELETE FROM users WHERE user_id=? AND status='inactive' param name=userId sqlType=INTEGER operation name=removeUser call-query href=deleteInactiveUser with-param name=userId query-param=userId"}
{"description": "Comprehensive data service with multiple operations including batch processing for bulk employee insertion, parameterized queries with optional filters, and complex result mappings with nested elements for department hierarchy", "reply": "data name=HRManagementService enableBatchRequests=true serviceNamespace=http://ws.wso2.org/dataservice config id=HRDatabase property name=driverClassName com.mysql.jdbc.Driver property name=url jdbc:mysql://localhost:3306/hrdb property name=username hruser property name=password hrpass123 query id=getEmployeesByDept useConfig=HRDatabase sql SELECT e.emp_id, e.emp_name, e.salary, d.dept_name, d.location FROM employees e INNER JOIN departments d ON e.dept_id=d.dept_id WHERE d.dept_name=? param name=department sqlType=STRING result element=Employees rowName=Employee element column=emp_id name=EmployeeID xsdType=integer element column=emp_name name=Name xsdType=string element column=salary name=Salary xsdType=double element column=dept_name name=DepartmentName xsdType=string element column=location name=Location xsdType=string query id=batchInsertEmployees useConfig=HRDatabase sql INSERT INTO employees (emp_name, dept_id, salary, hire_date) VALUES (?, ?, ?, NOW()) param name=name sqlType=STRING param name=deptId sqlType=INTEGER param name=salary sqlType=DOUBLE operation name=getEmployees call-query href=getEmployeesByDept with-param name=department query-param=dept operation name=addEmployeesBatch call-query href=batchInsertEmployees with-param name=name query-param=name with-param name=deptId query-param=deptId with-param name=salary query-param=salary"}
{"description": "Data service exposing MongoDB collection as REST API with JSON query operations to retrieve customer documents with filtering, projection, and custom result element mappings for NoSQL data integration", "reply": "data name=MongoCustomerService serviceNamespace=http://ws.wso2.org/dataservice config id=MongoDBSource property name=mongoDB_servers localhost property name=mongoDB_database customerdb property name=mongoDB_username mongouser property name=mongoDB_password mongopass query id=findCustomersByCity useConfig=MongoDBSource expression customers.find({\"city\":\"#city\"}) param name=city sqlType=STRING result element=Customers rowName=Customer element column=_id name=CustomerID xsdType=string element column=name name=CustomerName xsdType=string element column=email name=Email xsdType=string element column=city name=City xsdType=string operation name=getCustomersByCity call-query href=findCustomersByCity with-param name=city query-param=city"}
{"description": "Data service with Cassandra keyspace connection implementing CQL query to fetch time-series sensor data with timestamp filtering, result pagination, and column family mappings for IoT data exposure", "reply": "data name=SensorDataService serviceNamespace=http://ws.wso2.org/dataservice config id=CassandraCluster property name=cassandraServers localhost property name=port 9042 property name=keyspace iot_data property name=username cassandra property name=password cassandra query id=getSensorReadings useConfig=CassandraCluster cql SELECT sensor_id, timestamp, temperature, humidity FROM sensor_readings WHERE sensor_id=? AND timestamp >= ? LIMIT 100 param name=sensorId sqlType=STRING param name=fromTime sqlType=TIMESTAMP result element=Readings rowName=Reading element column=sensor_id name=SensorID xsdType=string element column=timestamp name=Timestamp xsdType=dateTime element column=temperature name=Temperature xsdType=double element column=humidity name=Humidity xsdType=double operation name=getSensorData call-query href=getSensorReadings with-param name=sensorId query-param=sensorId with-param name=fromTime query-param=from"}
{"description": "Advanced data service with stored procedure invocation for complex business logic, input and output parameter mappings, and multiple result sets handling for enterprise database integration", "reply": "data name=StoredProcService serviceNamespace=http://ws.wso2.org/dataservice config id=EnterpriseDB property name=driverClassName com.mysql.jdbc.Driver property name=url jdbc:mysql://localhost:3306/enterprisedb property name=username dbadmin property name=password dbadmin123 query id=processOrder useConfig=EnterpriseDB sql CALL process_customer_order(?, ?, ?) param name=customerId sqlType=INTEGER type=IN param name=orderAmount sqlType=DOUBLE type=IN param name=orderStatus sqlType=STRING type=OUT result element=OrderResult rowName=Status element column=orderStatus name=Status xsdType=string operation name=submitOrder call-query href=processOrder with-param name=customerId query-param=customerId with-param name=orderAmount query-param=amount"}
{"description": "Data service with JNDI datasource lookup for application server managed connection pooling, implementing query with JOIN operations across multiple tables and grouped result elements", "reply": "data name=JNDIDataService serviceNamespace=http://ws.wso2.org/dataservice config id=JNDISource property name=jndi_context_class com.sun.jndi.rmi.registry.RegistryContextFactory property name=jndi_provider_url rmi://localhost:2199 property name=jndi_resource_name jdbc/AppDataSource property name=jndi_password jndipass query id=getOrderDetails useConfig=JNDISource sql SELECT o.order_id, o.order_date, c.customer_name, p.product_name, od.quantity FROM orders o JOIN customers c ON o.customer_id=c.customer_id JOIN order_details od ON o.order_id=od.order_id JOIN products p ON od.product_id=p.product_id WHERE o.order_id=? param name=orderId sqlType=INTEGER result element=OrderDetails rowName=Item element column=order_id name=OrderID xsdType=integer element column=customer_name name=Customer xsdType=string element column=product_name name=Product xsdType=string element column=quantity name=Quantity xsdType=integer operation name=getOrderInfo call-query href=getOrderDetails with-param name=orderId query-param=orderId"}
{"description": "Data service implementing custom validators for input parameters with regex patterns, length constraints, and required field validation before executing database INSERT operations", "reply": "data name=ValidatedDataService serviceNamespace=http://ws.wso2.org/dataservice config id=ValidationDB property name=driverClassName com.mysql.jdbc.Driver property name=url jdbc:mysql://localhost:3306/appdb property name=username appuser property name=password apppass query id=insertValidatedRecord useConfig=ValidationDB sql INSERT INTO customers (email, phone, age) VALUES (?, ?, ?) param name=email sqlType=STRING validatePattern pattern=[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,} param name=phone sqlType=STRING validateLength minimum=10 maximum=15 param name=age sqlType=INTEGER validateRange minimum=18 maximum=120 operation name=addCustomer call-query href=insertValidatedRecord with-param name=email query-param=email with-param name=phone query-param=phone with-param name=age query-param=age"}
{"description": "Data service exposing RDF data store with SPARQL query support for semantic web integration, retrieving linked data with custom prefix mappings and graph pattern matching", "reply": "data name=SemanticDataService serviceNamespace=http://ws.wso2.org/dataservice config id=RDFStore property name=rdf_datasource http://localhost:3030/dataset property name=rdf_query_endpoint /sparql query id=getResourceInfo useConfig=RDFStore sparql PREFIX foaf: <http://xmlns.com/foaf/0.1/> SELECT ?name ?email WHERE { ?person foaf:name ?name . ?person foaf:email ?email . FILTER(?name = \"#name\") } param name=name sqlType=STRING result element=Resources rowName=Resource element column=name name=Name xsdType=string element column=email name=Email xsdType=string operation name=getResourceData call-query href=getResourceInfo with-param name=name query-param=name"}
{"description": "Data service with distributed SQL query execution across multiple datasources using federated queries, union operations, and result aggregation for cross-database reporting", "reply": "data name=FederatedQueryService serviceNamespace=http://ws.wso2.org/dataservice config id=DB1 property name=driverClassName com.mysql.jdbc.Driver property name=url jdbc:mysql://server1:3306/salesdb property name=username user1 property name=password pass1 config id=DB2 property name=driverClassName org.postgresql.Driver property name=url jdbc:postgresql://server2:5432/inventorydb property name=username user2 property name=password pass2 query id=getCombinedReport useConfig=DB1 sql SELECT product_id, product_name, sales_count FROM sales_data UNION SELECT product_id, product_name, stock_count FROM inventory_data result element=Report rowName=ProductData element column=product_id name=ProductID xsdType=string element column=product_name name=ProductName xsdType=string element column=sales_count name=Count xsdType=integer operation name=getConsolidatedReport call-query href=getCombinedReport"}
{"description": "Data service with box-carring enabled for executing multiple queries in single request, implementing transactional batch operations with rollback support and request box configuration", "reply": "data name=BatchTransactionService enableBoxcarring=true serviceNamespace=http://ws.wso2.org/dataservice config id=TransactionalDB property name=driverClassName com.mysql.jdbc.Driver property name=url jdbc:mysql://localhost:3306/transdb property name=username transuser property name=password transpass property name=autocommit false query id=insertAccount useConfig=TransactionalDB sql INSERT INTO accounts (account_no, balance) VALUES (?, ?) param name=accountNo sqlType=STRING param name=balance sqlType=DOUBLE query id=updateBalance useConfig=TransactionalDB sql UPDATE accounts SET balance=balance+? WHERE account_no=? param name=amount sqlType=DOUBLE param name=accountNo sqlType=STRING operation name=addAccount call-query href=insertAccount with-param name=accountNo query-param=accountNo with-param name=balance query-param=balance operation name=updateAccountBalance call-query href=updateBalance with-param name=amount query-param=amount with-param name=accountNo query-param=accountNo"}
{"description": "Data service with event notification support triggering external webhooks on data changes, implementing query with event triggers for INSERT operations and custom event payload formatting", "reply": "data name=EventDrivenDataService serviceNamespace=http://ws.wso2.org/dataservice config id=EventDB property name=driverClassName com.mysql.jdbc.Driver property name=url jdbc:mysql://localhost:3306/eventdb property name=username eventuser property name=password eventpass query id=insertWithNotification useConfig=EventDB sql INSERT INTO notifications (message, recipient, sent_date) VALUES (?, ?, NOW()) param name=message sqlType=STRING param name=recipient sqlType=STRING event-trigger id=notificationTrigger language=XPath expression /notifications/recipient target-topic NotificationTopic subscriptions subscription http://webhook.example.com/notify operation name=sendNotification call-query href=insertWithNotification with-param name=message query-param=message with-param name=recipient query-param=recipient"}
{"description": "Database lookup operation using dblookup mediator with MySQL connection pool to retrieve customer details by ID. Uses parameterized SQL query with JDBC driver configuration and result mapping to variables.", "reply": "dblookup connection pool driver com.mysql.jdbc.Driver url jdbc:mysql://localhost:3306/customerdb user dbuser password dbpass123 property name=maxActive value=50 property name=maxIdle value=10 statement sql SELECT name, email, phone FROM customers WHERE customer_id = ? parameter expression=${params.queryParams.customerId} type=INTEGER result name=customerName column=name result name=customerEmail column=email result name=customerPhone column=phone"}
{"description": "Database report mediator for inserting order records into PostgreSQL database with connection pooling. Implements parameterized insert statement with multiple typed parameters including VARCHAR, INTEGER, and DECIMAL data types.", "reply": "dbreport connection pool driver org.postgresql.Driver url jdbc:postgresql://localhost:5432/ordersdb user orderuser password order@2024 property name=initialSize value=5 statement sql INSERT INTO orders (order_id, customer_id, product_name, quantity, total_amount) VALUES (?, ?, ?, ?, ?) parameter expression=${payload.orderId} type=VARCHAR parameter expression=${payload.customerId} type=INTEGER parameter expression=${payload.productName} type=VARCHAR parameter expression=${payload.quantity} type=INTEGER parameter expression=${payload.totalAmount} type=DECIMAL"}
{"description": "Simple dblookup mediator configuration for product inventory check using Oracle database. Retrieves stock quantity and warehouse location with single parameter query and basic connection pool settings.", "reply": "dblookup connection pool driver oracle.jdbc.driver.OracleDriver url jdbc:oracle:thin:@localhost:1521:orcl user invuser password inv2024 statement sql SELECT stock_qty, warehouse FROM inventory WHERE product_id = ? parameter expression=${payload.productId} type=VARCHAR result name=stockQuantity column=stock_qty result name=warehouseLocation column=warehouse"}
{"description": "Database update operation using dbreport mediator to modify employee salary records in MySQL. Includes WHERE clause with parameterized query for targeted updates and connection pool configuration with timeout properties.", "reply": "dbreport connection pool driver com.mysql.jdbc.Driver url jdbc:mysql://localhost:3306/hrdb user hruser password hrpass456 property name=maxWait value=10000 property name=testOnBorrow value=true statement sql UPDATE employees SET salary = ?, last_updated = NOW() WHERE employee_id = ? parameter expression=${payload.newSalary} type=DECIMAL parameter expression=${payload.employeeId} type=INTEGER"}
{"description": "Complex database lookup with multiple result columns using dblookup mediator for retrieving complete user profile including timestamps. Maps DATE and TIMESTAMP columns to variables with JDBC type specifications.", "reply": "dblookup connection pool driver com.mysql.jdbc.Driver url jdbc:mysql://localhost:3306/userdb user appuser password app@secure property name=maxActive value=100 statement sql SELECT username, email, registration_date, last_login, status FROM users WHERE user_id = ? parameter expression=${vars.userId} type=INTEGER result name=userName column=username result name=userEmail column=email result name=regDate column=registration_date result name=lastLogin column=last_login result name=accountStatus column=status"}
{"description": "Batch insert operation using dbreport mediator for logging multiple transaction records. Implements SQL INSERT statement with timestamp parameter of TIMESTAMP type for audit trail in PostgreSQL database.", "reply": "dbreport connection pool driver org.postgresql.Driver url jdbc:postgresql://localhost:5432/auditdb user audituser password audit@log statement sql INSERT INTO transaction_log (transaction_id, user_id, action, amount, timestamp) VALUES (?, ?, ?, ?, ?) parameter expression=${payload.txnId} type=VARCHAR parameter expression=${payload.userId} type=INTEGER parameter expression=${payload.action} type=VARCHAR parameter expression=${payload.amount} type=DECIMAL parameter expression=${now()} type=TIMESTAMP"}
{"description": "Database lookup for authentication using dblookup mediator with password verification. Retrieves hashed password and account status from users table with prepared statement and connection pool retry configuration.", "reply": "dblookup connection pool driver com.mysql.jdbc.Driver url jdbc:mysql://localhost:3306/authdb user authuser password authpass789 property name=maxActive value=75 property name=testWhileIdle value=true statement sql SELECT password_hash, account_status, failed_attempts FROM users WHERE username = ? parameter expression=${payload.username} type=VARCHAR result name=passwordHash column=password_hash result name=accountStatus column=account_status result name=failedAttempts column=failed_attempts"}
{"description": "Delete operation using dbreport mediator to remove expired session records from database. Parameterized DELETE statement with timestamp comparison and connection pool with validation query for MySQL.", "reply": "dbreport connection pool driver com.mysql.jdbc.Driver url jdbc:mysql://localhost:3306/sessiondb user sessionuser password session@clean property name=validationQuery value=SELECT 1 statement sql DELETE FROM sessions WHERE session_id = ? AND expiry_time < NOW() parameter expression=${vars.sessionId} type=VARCHAR"}
{"description": "Multi-parameter database query using dblookup mediator for complex financial report generation. Retrieves aggregated transaction data with date range parameters using BETWEEN clause and multiple column result mapping.", "reply": "dblookup connection pool driver org.postgresql.Driver url jdbc:postgresql://localhost:5432/financedb user finuser password finance$123 property name=maxActive value=60 statement sql SELECT SUM(amount) as total, COUNT(*) as count, AVG(amount) as average FROM transactions WHERE account_id = ? AND transaction_date BETWEEN ? AND ? parameter expression=${payload.accountId} type=INTEGER parameter expression=${payload.startDate} type=DATE parameter expression=${payload.endDate} type=DATE result name=totalAmount column=total result name=transactionCount column=count result name=averageAmount column=average"}
{"description": "Database insert with dbreport mediator for creating new customer account records. Implements prepared statement with multiple VARCHAR and INTEGER parameters and connection pooling with minimum idle connections.", "reply": "dbreport connection pool driver com.mysql.jdbc.Driver url jdbc:mysql://localhost:3306/crmdb user crmuser password crm@2024 property name=minIdle value=5 property name=maxIdle value=15 statement sql INSERT INTO customers (first_name, last_name, email, phone, address, city, country) VALUES (?, ?, ?, ?, ?, ?, ?) parameter expression=${payload.firstName} type=VARCHAR parameter expression=${payload.lastName} type=VARCHAR parameter expression=${payload.email} type=VARCHAR parameter expression=${payload.phone} type=VARCHAR parameter expression=${payload.address} type=VARCHAR parameter expression=${payload.city} type=VARCHAR parameter expression=${payload.country} type=VARCHAR"}
{"description": "Lookup operation for product details retrieval using dblookup with JOIN query. Fetches product information along with category and supplier data using parameterized SQL with result column mapping.", "reply": "dblookup connection pool driver com.mysql.jdbc.Driver url jdbc:mysql://localhost:3306/catalogdb user cataloguser password catalog#456 statement sql SELECT p.name, p.price, c.category_name, s.supplier_name FROM products p JOIN categories c ON p.category_id = c.id JOIN suppliers s ON p.supplier_id = s.id WHERE p.product_id = ? parameter expression=${params.pathParams.productId} type=INTEGER result name=productName column=name result name=productPrice column=price result name=categoryName column=category_name result name=supplierName column=supplier_name"}
{"description": "Update operation with dbreport mediator to increment product view counter in database. Uses parameterized UPDATE with arithmetic operation and connection pool eviction configuration for PostgreSQL.", "reply": "dbreport connection pool driver org.postgresql.Driver url jdbc:postgresql://localhost:5432/analyticsdb user analyticsuser password analytics@789 property name=timeBetweenEvictionRunsMillis value=30000 statement sql UPDATE product_stats SET view_count = view_count + 1, last_viewed = CURRENT_TIMESTAMP WHERE product_id = ? parameter expression=${payload.productId} type=VARCHAR"}
{"description": "Database lookup with conditional filtering using dblookup mediator for order status retrieval. Implements WHERE clause with multiple conditions and result mapping for order details and shipping information.", "reply": "dblookup connection pool driver com.mysql.jdbc.Driver url jdbc:mysql://localhost:3306/orderdb user orderadmin password order#admin property name=maxActive value=80 statement sql SELECT order_status, shipping_address, tracking_number, estimated_delivery FROM orders WHERE order_id = ? AND customer_id = ? parameter expression=${params.queryParams.orderId} type=VARCHAR parameter expression=${vars.customerId} type=INTEGER result name=orderStatus column=order_status result name=shippingAddress column=shipping_address result name=trackingNumber column=tracking_number result name=estimatedDelivery column=estimated_delivery"}
{"description": "Batch update using dbreport mediator for inventory adjustment after order processing. Updates stock quantities with parameterized query and connection pooling with remove abandoned timeout configuration.", "reply": "dbreport connection pool driver com.mysql.jdbc.Driver url jdbc:mysql://localhost:3306/inventorydb user invadmin password inventory$2024 property name=removeAbandonedTimeout value=300 statement sql UPDATE inventory SET quantity = quantity - ?, last_updated = NOW() WHERE product_id = ? AND warehouse_id = ? parameter expression=${payload.quantity} type=INTEGER parameter expression=${payload.productId} type=VARCHAR parameter expression=${payload.warehouseId} type=INTEGER"}
{"description": "Complex API integration with database lookup followed by HTTP call. Uses dblookup to retrieve API credentials from configuration table, then invokes external service with enriched payload and error handling.", "reply": "api context=/customer name=CustomerLookupAPI resource methods=GET uri-template=/{customerId} inSequence dblookup connection pool driver com.mysql.jdbc.Driver url jdbc:mysql://localhost:3306/customerdb user apiuser password api@pass statement sql SELECT name, email, loyalty_points FROM customers WHERE id = ? parameter expression=${params.pathParams.customerId} type=INTEGER result name=custName column=name result name=custEmail column=email result name=points column=loyalty_points payloadFactory media-type=json format {\"name\":\"${vars.custName}\",\"email\":\"${vars.custEmail}\",\"points\":${vars.points}} respond"}
{"description": "Transaction processing with multiple database operations using dbreport and dblookup mediators. Validates account balance with lookup, performs debit operation with report, and logs transaction with timestamp parameters.", "reply": "sequence name=TransferSequence dblookup connection pool driver org.postgresql.Driver url jdbc:postgresql://localhost:5432/bankdb user bankuser password bank@secure statement sql SELECT balance FROM accounts WHERE account_number = ? parameter expression=${payload.fromAccount} type=VARCHAR result name=currentBalance column=balance dbreport connection pool driver org.postgresql.Driver url jdbc:postgresql://localhost:5432/bankdb user bankuser password bank@secure statement sql UPDATE accounts SET balance = balance - ? WHERE account_number = ? parameter expression=${payload.amount} type=DECIMAL parameter expression=${payload.fromAccount} type=VARCHAR respond"}
{"description": "Database query with aggregate functions using dblookup mediator for analytics dashboard. Retrieves sales statistics including sum, count, and average with GROUP BY clause and date range filtering.", "reply": "dblookup connection pool driver com.mysql.jdbc.Driver url jdbc:mysql://localhost:3306/salesdb user salesuser password sales@report property name=maxActive value=100 statement sql SELECT region, SUM(sale_amount) as total_sales, COUNT(*) as num_transactions, AVG(sale_amount) as avg_sale FROM sales WHERE sale_date BETWEEN ? AND ? GROUP BY region parameter expression=${payload.startDate} type=DATE parameter expression=${payload.endDate} type=DATE result name=salesRegion column=region result name=totalSales column=total_sales result name=transactionCount column=num_transactions result name=averageSale column=avg_sale"}
{"description": "Audit logging system using dbreport mediator with comprehensive parameter types. Inserts audit trail records with user information, action details, IP address, and timestamp for compliance tracking in Oracle database.", "reply": "dbreport connection pool driver oracle.jdbc.driver.OracleDriver url jdbc:oracle:thin:@localhost:1521:orcl user audituser password audit@oracle property name=maxActive value=50 property name=maxWait value=15000 statement sql INSERT INTO audit_log (user_id, action_type, resource_id, ip_address, user_agent, timestamp, status) VALUES (?, ?, ?, ?, ?, ?, ?) parameter expression=${headers.userId} type=INTEGER parameter expression=${props.synapse.REST_METHOD} type=VARCHAR parameter expression=${params.pathParams.resourceId} type=VARCHAR parameter expression=${headers['X-Forwarded-For']} type=VARCHAR parameter expression=${headers['User-Agent']} type=VARCHAR parameter expression=${now()} type=TIMESTAMP parameter expression=${vars.responseStatus} type=VARCHAR"}
{"description": "Product search API with database lookup using LIKE operator for partial matching. Implements dblookup with wildcard parameter for name-based product search with category filtering and result limit.", "reply": "api context=/search name=ProductSearchAPI resource methods=GET uri-template=/products inSequence variable name=searchTerm expression=${params.queryParams.q} type=STRING dblookup connection pool driver com.mysql.jdbc.Driver url jdbc:mysql://localhost:3306/productdb user searchuser password search@123 statement sql SELECT product_id, name, description, price FROM products WHERE name LIKE ? LIMIT 20 parameter expression=${vars.searchTerm} type=VARCHAR result name=productId column=product_id result name=productName column=name result name=description column=description result name=price column=price respond"}
{"description": "User registration workflow combining validation lookup and insert operations. First checks email uniqueness with dblookup, then creates new user record with dbreport including password hash and registration timestamp.", "reply": "sequence name=UserRegistration dblookup connection pool driver com.mysql.jdbc.Driver url jdbc:mysql://localhost:3306/userdb user reguser password register@pwd statement sql SELECT COUNT(*) as cnt FROM users WHERE email = ? parameter expression=${payload.email} type=VARCHAR result name=emailCount column=cnt filter xpath=${integer(vars.emailCount) == 0} then dbreport connection pool driver com.mysql.jdbc.Driver url jdbc:mysql://localhost:3306/userdb user reguser password register@pwd statement sql INSERT INTO users (username, email, password_hash, created_at) VALUES (?, ?, ?, NOW()) parameter expression=${payload.username} type=VARCHAR parameter expression=${payload.email} type=VARCHAR parameter expression=${payload.passwordHash} type=VARCHAR respond"}
{"description": "HTTP endpoint configuration with address endpoint type targeting a REST service at localhost port 8280. Uses basic endpoint structure with URI property for GET requests to retrieve user data.", "reply": "localEntry key=UserServiceEndpoint http.init connectionType http baseUrl http://localhost:8280/users name UserServiceEndpoint"}
{"description": "Address endpoint with timeout configuration including response timeout of 30 seconds and connection timeout of 15 seconds. Implements error handling with suspend on failure settings for 3 retries with 5 second intervals.", "reply": "localEntry key=PaymentServiceEndpoint http.init connectionType https baseUrl https://api.payment.com/process timeoutDuration 30 timeoutAction Discard retryErrorCodes 500,502,503 retryCount 3 retryDelay 5 name PaymentServiceEndpoint"}
{"description": "Failover endpoint configuration with primary and secondary endpoints for high availability. Routes requests to backup endpoint when primary fails, implementing automatic failover pattern with error code detection.", "reply": "endpoint name=FailoverEndpoint failover endpoint address uri=http://primary.service.com/api endpoint address uri=http://secondary.service.com/api"}
{"description": "Load balance endpoint with round-robin algorithm distributing traffic across three backend servers. Implements session affinity disabled and equal weight distribution for horizontal scaling of microservices.", "reply": "endpoint name=LoadBalanceEndpoint loadbalance algorithm=roundRobin endpoint address uri=http://server1.example.com:8080/service endpoint address uri=http://server2.example.com:8080/service endpoint address uri=http://server3.example.com:8080/service"}
{"description": "Dynamic endpoint selection using header-based routing with variable mediator extracting target URL from HTTP headers. Implements runtime endpoint resolution for multi-tenant architecture.", "reply": "sequence name=DynamicRoutingSequence variable name=targetEndpoint expression=${headers.TargetService} type=STRING http.init connectionType http baseUrl ${vars.targetEndpoint} name DynamicEndpoint http.get configKey=DynamicEndpoint relativePath /api/data"}
{"description": "WSDL endpoint configuration targeting SOAP service with endpoint reference derived from WSDL definition. Includes service and port specification for proper SOAP message addressing.", "reply": "endpoint name=SOAPServiceEndpoint wsdl uri=http://services.example.com/stockquote?wsdl service=StockQuoteService port=StockQuotePort"}
{"description": "HTTP endpoint with basic authentication credentials configured for secured backend service access. Implements username and password encoding in connection configuration for protected API calls.", "reply": "localEntry key=SecureAPIEndpoint http.init connectionType https baseUrl https://secure.api.com/v1 authType Basic Auth basicCredentialsUsername apiuser basicCredentialsPassword apiP@ssw0rd name SecureAPIEndpoint"}
{"description": "Endpoint suspension configuration with progressive delay calculation for circuit breaker pattern. Suspends endpoint after 3 consecutive failures with initial 10 second duration and progression factor of 2.", "reply": "localEntry key=CircuitBreakerEndpoint http.init connectionType http baseUrl http://unreliable.service.com/api suspendErrorCodes 500,503,504 suspendInitialDuration 10000 suspendProgressionFactor 2 suspendMaximumDuration 60000 name CircuitBreakerEndpoint"}
{"description": "Recipient list endpoint configuration routing messages to multiple destinations based on dynamic recipient list. Implements scatter-gather pattern with parallel message delivery to configured endpoints.", "reply": "endpoint name=RecipientListEndpoint recipientlist endpoint address uri=http://recipient1.com/notify endpoint address uri=http://recipient2.com/notify endpoint address uri=http://recipient3.com/notify"}
{"description": "Default endpoint configuration serving as fallback when no specific routing conditions match. Acts as catch-all endpoint in content-based routing scenarios with standard timeout settings.", "reply": "endpoint name=DefaultBackendEndpoint default address uri=http://default.backend.com/api timeout duration 45000 responseAction fault"}
{"description": "Load balance endpoint with weighted distribution algorithm routing 70% traffic to primary server and 30% to secondary. Implements canary deployment pattern with unequal load distribution.", "reply": "endpoint name=WeightedLoadBalancer loadbalance algorithm=weightedRoundRobin endpoint address uri=http://primary.service.com/api property name=loadbalance.weight value=70 endpoint address uri=http://canary.service.com/api property name=loadbalance.weight value=30"}
{"description": "API resource with dynamic endpoint resolution based on query parameter value. Uses filter mediator to route requests to different backend services determined by customer tier level.", "reply": "api context=/customers name=CustomerRoutingAPI resource methods=GET uri-template=/profile inSequence filter xpath=${params.queryParams.tier == 'premium'} then http.get configKey=PremiumServiceEndpoint relativePath /premium/profile else http.get configKey=StandardServiceEndpoint relativePath /standard/profile respond"}
{"description": "Failover endpoint with retry configuration attempting primary endpoint three times before switching to backup. Implements resilient routing with progressive retry delays and error code matching.", "reply": "endpoint name=ResilientFailoverEndpoint failover endpoint address uri=http://primary.api.com/service timeout duration 20000 responseAction fault suspendOnFailure errorCodes 500,502,503 initialDuration 15000 progressionFactor 1.5 maximumDuration 60000 markForSuspension retriesBeforeSuspension 3 retryDelay 2000 endpoint address uri=http://backup.api.com/service"}
{"description": "Content-based routing with switch mediator evaluating payload field to select appropriate backend endpoint. Routes order processing requests to different services based on order type value.", "reply": "sequence name=OrderRoutingSequence switch source=${payload.orderType} case regex=express http.post configKey=ExpressOrderEndpoint relativePath /orders/express requestBodyType JSON requestBodyJson ${payload} case regex=standard http.post configKey=StandardOrderEndpoint relativePath /orders/standard requestBodyType JSON requestBodyJson ${payload} default http.post configKey=DefaultOrderEndpoint relativePath /orders requestBodyType JSON requestBodyJson ${payload} respond"}
{"description": "Template endpoint pattern with parameterized URI construction using variable mediator. Implements reusable endpoint configuration accepting dynamic path segments for multi-resource API access.", "reply": "sequence name=TemplateEndpointSequence variable name=resourceId expression=${payload.id} type=STRING variable name=resourceType expression=${payload.type} type=STRING http.get configKey=ResourceAPIEndpoint relativePath /${vars.resourceType}/${vars.resourceId} headers [[\"Accept\",\"application/json\"]] respond"}
{"description": "Load balance endpoint with session affinity enabled using client IP-based sticky sessions. Routes subsequent requests from same client to consistent backend server for stateful application support.", "reply": "endpoint name=SessionAffinityLoadBalancer session type=simpleClientSession loadbalance algorithm=roundRobin endpoint address uri=http://app-server1.com:8080/webapp endpoint address uri=http://app-server2.com:8080/webapp endpoint address uri=http://app-server3.com:8080/webapp"}
{"description": "Endpoint with comprehensive timeout and error handling configuration including connection timeout, socket timeout, and HTTP status code-based suspension. Implements complete resilience pattern with retry logic.", "reply": "localEntry key=ResilientServiceEndpoint http.init connectionType https baseUrl https://critical.service.com/api timeoutDuration 25 timeoutAction Fault retryErrorCodes 408,429,500,502,503,504 retryCount 5 retryDelay 3 suspendErrorCodes 500,503 suspendInitialDuration 20000 suspendProgressionFactor 2 suspendMaximumDuration 120000 name ResilientServiceEndpoint"}
{"description": "Header-based dynamic routing implementation extracting service version from custom HTTP header and constructing versioned endpoint URL. Supports API versioning strategy with backward compatibility.", "reply": "api context=/products name=VersionedProductAPI resource methods=GET uri-template=/{productId} inSequence variable name=apiVersion expression=${headers['API-Version']} type=STRING variable name=productId expression=${params.pathParams.productId} type=STRING http.get configKey=ProductServiceEndpoint relativePath /${vars.apiVersion}/products/${vars.productId} headers [[\"Content-Type\",\"application/json\"]] respond"}
{"description": "Scatter-gather pattern with recipient list endpoint aggregating responses from multiple microservices. Executes parallel calls to inventory, pricing, and availability services with response aggregation logic.", "reply": "sequence name=ProductDetailsAggregation variable name=productId expression=${params.queryParams.productId} type=STRING scatter-gather parallel-execution=true target=Body result-content-type=JSON aggregation expression=${payload} sequence http.get configKey=InventoryServiceEndpoint relativePath /inventory/${vars.productId} sequence http.get configKey=PricingServiceEndpoint relativePath /pricing/${vars.productId} sequence http.get configKey=AvailabilityServiceEndpoint relativePath /availability/${vars.productId} respond"}
{"description": "Complex failover configuration with health check endpoint and automatic recovery. Implements active health monitoring with periodic checks, suspension on consecutive failures, and gradual traffic restoration upon recovery.", "reply": "endpoint name=HealthCheckFailoverEndpoint failover endpoint address uri=http://service-primary.cloud.com/api timeout duration 30000 responseAction fault suspendOnFailure errorCodes -1,101500,101501,101503,101504,101505,101506,101507,101508,500,502,503 initialDuration 30000 progressionFactor 1.0 maximumDuration 300000 markForSuspension retriesBeforeSuspension 2 retryDelay 1000 endpoint address uri=http://service-backup.cloud.com/api timeout duration 30000"}
{"description": "API fault sequence that logs error details using synapse properties and responds with a 500 status code. Uses log mediator with ERROR category to capture error code and message, followed by payloadFactory to construct JSON error response with timestamp.", "reply": "api context=/healthcare name=HealthcareAPI resource methods=GET uri-template=/doctor/{category} inSequence respond faultSequence log category=ERROR message Error occurred: ${props.synapse.ERROR_CODE} - ${props.synapse.ERROR_MESSAGE} payloadFactory media-type=json format {\"error\":\"${props.synapse.ERROR_MESSAGE}\",\"code\":\"${props.synapse.ERROR_CODE}\",\"timestamp\":${now()}} header name=HTTP_SC value=500 scope=axis2 respond"}
{"description": "ThrowError mediator implementation that validates required payload fields and throws PAYLOAD_ERROR with custom message. Uses filter mediator to check field existence, throws error if validation fails, otherwise processes request normally.", "reply": "api context=/order name=OrderAPI resource methods=POST inSequence filter xpath=${exists(payload.customerId) and exists(payload.amount)} then respond else throwError type=PAYLOAD_ERROR errorMessage=Required fields customerId and amount are missing faultSequence log category=ERROR message Validation failed: ${props.synapse.ERROR_MESSAGE} header name=HTTP_SC value=400 scope=axis2 respond"}
{"description": "Custom fault sequence with error categorization logic. Uses switch mediator on ERROR_CODE to return different HTTP status codes: 401 for authentication errors, 404 for not found, 503 for timeout, and 500 for generic errors.", "reply": "sequence name=CustomErrorHandler switch source=${props.synapse.ERROR_CODE} case regex=401.* header name=HTTP_SC value=401 scope=axis2 payloadFactory media-type=json format {\"error\":\"Unauthorized\",\"message\":\"${props.synapse.ERROR_MESSAGE}\"} case regex=404.* header name=HTTP_SC value=404 scope=axis2 payloadFactory media-type=json format {\"error\":\"Not Found\",\"message\":\"Resource not available\"} case regex=.*timeout.* header name=HTTP_SC value=503 scope=axis2 payloadFactory media-type=json format {\"error\":\"Service Unavailable\",\"message\":\"Backend timeout\"} default header name=HTTP_SC value=500 scope=axis2 payloadFactory media-type=json format {\"error\":\"Internal Error\",\"code\":\"${props.synapse.ERROR_CODE}\"} respond"}
{"description": "Sequence with custom fault handler that stores error details in variables and constructs detailed error response. Captures error code, message, detail, and exception using synapse properties, then formats comprehensive JSON response.", "reply": "sequence name=\"ProcessOrder\" onError=\"OrderFaultHandler\" xmlns=\"http://ws.apache.org/ns/synapse\" log category=\"INFO\" message Processing order respond sequence name=\"OrderFaultHandler\" xmlns=\"http://ws.apache.org/ns/synapse\" variable name=\"errorCode\" type=\"STRING\" expression=\"${props.synapse.ERROR_CODE}\" variable name=\"errorMsg\" type=\"STRING\" expression=\"${props.synapse.ERROR_MESSAGE}\" variable name=\"errorDetail\" type=\"STRING\" expression=\"${props.synapse.ERROR_DETAIL}\" payloadFactory media-type=\"json\" format {\"status\":\"failed\",\"errorCode\":\"${vars.errorCode}\",\"errorMessage\":\"${vars.errorMsg}\",\"errorDetail\":\"${vars.errorDetail}\",\"timestamp\":\"${formatDateTime(now(),\"yyyy-MM-dd T HH:mm:ss\")}\"} header name=\"HTTP_SC\" value=\"500\" scope=\"axis2\" respond"}
{"description": "Fault sequence implementing retry logic with scatter-gather error recovery. Attempts primary service call, falls back to secondary endpoint on failure, logs all attempts, and returns appropriate error if all endpoints fail.", "reply": "api context=/payment name=PaymentAPI resource methods=POST inSequence variable name=attempt type=INTEGER value=1 http.post configKey=PrimaryPaymentService relativePath /process headers [] requestBodyType JSON requestBodyJson ${payload} respond faultSequence log category=WARN message Primary service failed, attempting fallback filter xpath=${vars.attempt < 2} then variable name=attempt type=INTEGER value=2 http.post configKey=SecondaryPaymentService relativePath /process headers [] requestBodyType JSON requestBodyJson ${payload} else payloadFactory media-type=json format {\"error\":\"All payment services unavailable\",\"code\":\"SERVICE_DOWN\"} header name=HTTP_SC value=503 scope=axis2 respond"}
{"description": "Simple fault sequence with basic error logging and generic error response. Logs error at ERROR level and returns standardized 500 error with minimal details for security.", "reply": "sequence name=BasicFaultHandler log category=ERROR message Error: ${props.synapse.ERROR_MESSAGE} payloadFactory media-type=json format {\"error\":\"Internal server error occurred\"} header name=HTTP_SC value=500 scope=axis2 respond"}
{"description": "ThrowError mediator with dynamic error message construction using variables. Validates minimum order amount, constructs error message with actual and required amounts, throws VALIDATION_ERROR if check fails.", "reply": "api context=/validate name=ValidateAPI resource methods=POST inSequence variable name=minAmount type=INTEGER value=100 filter xpath=${payload.amount < vars.minAmount} then variable name=errorMsg type=STRING expression=${concat('Order amount ',string(payload.amount),' is below minimum ',string(vars.minAmount))} throwError type=VALIDATION_ERROR errorMessage={${vars.errorMsg}} else respond faultSequence header name=HTTP_SC value=400 scope=axis2 respond"}
{"description": "Fault handler that differentiates between client and server errors using ERROR_CODE patterns. Returns 4xx for client errors with detailed messages, 5xx for server errors with minimal information to avoid exposure.", "reply": "sequence name=SmartErrorHandler filter xpath=${startsWith(props.synapse.ERROR_CODE,'4')} then payloadFactory media-type=json format {\"error\":\"Client Error\",\"message\":\"${props.synapse.ERROR_MESSAGE}\",\"code\":\"${props.synapse.ERROR_CODE}\"} header name=HTTP_SC expression=${props.synapse.ERROR_CODE} scope=axis2 else payloadFactory media-type=json format {\"error\":\"Server Error\",\"message\":\"An internal error occurred\"} header name=HTTP_SC value=500 scope=axis2 respond"}
{"description": "Database error handling with specific fault sequence. Uses dblookup mediator, catches SQL exceptions in fault handler, logs database errors separately, returns 503 status indicating service unavailability.", "reply": "api context=/customer name=CustomerAPI resource methods=GET uri-template=/{id} inSequence dblookup connection pool driver com.mysql.jdbc.Driver url jdbc:mysql://localhost:3306/customerdb user dbuser password dbpass123 statement sql SELECT * FROM customers WHERE id = ? parameter expression=${params.pathParams.id} type=INTEGER result name=customer_data column=data respond faultSequence log category=ERROR message Database error: ${props.synapse.ERROR_MESSAGE} payloadFactory media-type=json format {\"error\":\"Database service unavailable\",\"details\":\"Unable to retrieve customer data\"} header name=HTTP_SC value=503 scope=axis2 respond"}
{"description": "Comprehensive error handling with error notification sequence. Captures all error properties, sends error notification to monitoring endpoint, logs complete error context, constructs user-friendly response.", "reply": "api context=/transaction name=TransactionAPI resource methods=POST inSequence respond faultSequence variable name=errorCode type=STRING expression=${props.synapse.ERROR_CODE} variable name=errorMsg type=STRING expression=${props.synapse.ERROR_MESSAGE} variable name=errorDetail type=STRING expression=${props.synapse.ERROR_DETAIL} variable name=requestId type=STRING expression=${headers['X-Request-ID']} log category=ERROR message Transaction failed - RequestID: ${vars.requestId}, Code: ${vars.errorCode}, Message: ${vars.errorMsg} payloadFactory media-type=json format {\"service\":\"monitoring\",\"errorCode\":\"${vars.errorCode}\",\"errorMessage\":\"${vars.errorMsg}\",\"requestId\":\"${vars.requestId}\",\"timestamp\":${now()}} http.post configKey=MonitoringService relativePath /errors headers [] requestBodyType JSON requestBodyJson ${payload} payloadFactory media-type=json format {\"status\":\"error\",\"requestId\":\"${vars.requestId}\",\"message\":\"Transaction processing failed\"} header name=HTTP_SC value=500 scope=axis2 respond"}
{"description": "Fault sequence with conditional error response based on environment. Uses configs to determine environment, returns detailed errors in development, sanitized errors in production for security.", "reply": "sequence name=EnvironmentAwareFaultHandler filter xpath=${configs.environment == 'production'} then payloadFactory media-type=json format {\"error\":\"An error occurred\",\"requestId\":\"${headers['X-Request-ID']}\"} else payloadFactory media-type=json format {\"error\":\"${props.synapse.ERROR_MESSAGE}\",\"code\":\"${props.synapse.ERROR_CODE}\",\"detail\":\"${props.synapse.ERROR_DETAIL}\",\"exception\":\"${props.synapse.ERROR_EXCEPTION}\"} log category=ERROR message Error in ${configs.environment}: ${props.synapse.ERROR_CODE} header name=HTTP_SC value=500 scope=axis2 respond"}
{"description": "Multi-level validation with throwError for different validation failures. Checks multiple required fields sequentially, throws specific VALIDATION_ERROR for each missing field with descriptive messages.", "reply": "api context=/registration name=RegistrationAPI resource methods=POST inSequence filter xpath=${not(exists(payload.email))} then throwError type=VALIDATION_ERROR errorMessage=Email field is required filter xpath=${not(exists(payload.username))} then throwError type=VALIDATION_ERROR errorMessage=Username field is required filter xpath=${not(exists(payload.password))} then throwError type=VALIDATION_ERROR errorMessage=Password field is required respond faultSequence payloadFactory media-type=json format {\"status\":\"validation_failed\",\"error\":\"${props.synapse.ERROR_MESSAGE}\"} header name=HTTP_SC value=400 scope=axis2 respond"}
{"description": "Error handling with circuit breaker pattern. Tracks consecutive failures in variable, opens circuit after threshold, returns cached response or error during cooldown period, resets on success.", "reply": "api context=/product name=ProductAPI resource methods=GET uri-template=/{id} inSequence variable name=failureCount type=INTEGER value=0 filter xpath=${vars.failureCount >= 3} then payloadFactory media-type=json format {\"error\":\"Circuit breaker open\",\"message\":\"Service temporarily unavailable\"} header name=HTTP_SC value=503 scope=axis2 respond else http.get configKey=ProductService relativePath /products/${params.pathParams.id} headers [] variable name=failureCount type=INTEGER value=0 respond faultSequence variable name=failureCount type=INTEGER expression=${vars.failureCount + 1} log category=WARN message Service failure count: ${vars.failureCount} payloadFactory media-type=json format {\"error\":\"Service unavailable\",\"retryAfter\":60} header name=HTTP_SC value=503 scope=axis2 respond"}
{"description": "Fault handler with correlation ID tracking for distributed tracing. Extracts or generates correlation ID, includes in all log statements, adds to error response headers for request tracking across services.", "reply": "api context=/booking name=BookingAPI resource methods=POST inSequence variable name=correlationId type=STRING expression=${headers['X-Correlation-ID'] != null ? headers['X-Correlation-ID'] : concat('REQ-',string(now()))} header name=X-Correlation-ID expression=${vars.correlationId} scope=transport respond faultSequence log category=ERROR message Booking failed - CorrelationID: ${vars.correlationId}, Error: ${props.synapse.ERROR_CODE} - ${props.synapse.ERROR_MESSAGE} payloadFactory media-type=json format {\"status\":\"error\",\"correlationId\":\"${vars.correlationId}\",\"error\":\"Booking service encountered an error\",\"timestamp\":${now()}} header name=X-Correlation-ID expression=${vars.correlationId} scope=transport header name=HTTP_SC value=500 scope=axis2 respond"}
{"description": "Error handling with enriched response using enrich mediator. Preserves original request payload in fault sequence, includes it in error response for debugging, adds error metadata from synapse properties.", "reply": "api context=/process name=ProcessAPI resource methods=POST inSequence variable name=originalPayload type=JSON expression=${payload} respond faultSequence payloadFactory media-type=json format {\"error\":{\"code\":\"${props.synapse.ERROR_CODE}\",\"message\":\"${props.synapse.ERROR_MESSAGE}\"},\"originalRequest\":${vars.originalPayload},\"timestamp\":${now()}} log category=ERROR message Processing failed for request: ${vars.originalPayload} header name=HTTP_SC value=500 scope=axis2 respond"}
{"description": "Simple throwError implementation for timeout scenarios. Checks response time variable, throws SERVICE_TIMEOUT error if threshold exceeded, includes timeout duration in error message.", "reply": "sequence name=TimeoutChecker variable name=timeoutThreshold type=INTEGER value=5000 variable name=responseTime type=INTEGER value=6000 filter xpath=${vars.responseTime > vars.timeoutThreshold} then throwError type=SERVICE_TIMEOUT errorMessage=Request exceeded timeout threshold of 5000ms"}
{"description": "Fault sequence with error aggregation for batch operations. Collects multiple error details, constructs array of failed items with reasons, returns 207 Multi-Status with partial success information.", "reply": "api context=/batch name=BatchAPI resource methods=POST inSequence variable name=failedItems type=JSON value=[] variable name=successCount type=INTEGER value=0 respond faultSequence log category=ERROR message Batch operation failed: ${props.synapse.ERROR_MESSAGE} payloadFactory media-type=json format {\"status\":\"partial_success\",\"successCount\":${vars.successCount},\"failedItems\":${vars.failedItems},\"errors\":[{\"code\":\"${props.synapse.ERROR_CODE}\",\"message\":\"${props.synapse.ERROR_MESSAGE}\"}]} header name=HTTP_SC value=207 scope=axis2 respond"}
{"description": "Structured error logging with different log levels based on error severity. Analyzes error code, logs FATAL for critical errors, ERROR for server issues, WARN for client errors, includes contextual information.", "reply": "sequence name=SeverityBasedLogger filter xpath=${contains(props.synapse.ERROR_CODE,'CRITICAL')} then log category=FATAL message CRITICAL ERROR: ${props.synapse.ERROR_CODE} - ${props.synapse.ERROR_MESSAGE} | Detail: ${props.synapse.ERROR_DETAIL} else filter xpath=${startsWith(props.synapse.ERROR_CODE,'5')} then log category=ERROR message Server Error: ${props.synapse.ERROR_CODE} - ${props.synapse.ERROR_MESSAGE} else log category=WARN message Client Error: ${props.synapse.ERROR_CODE} - ${props.synapse.ERROR_MESSAGE} payloadFactory media-type=json format {\"error\":\"${props.synapse.ERROR_MESSAGE}\"} respond"}
{"description": "Fault handler with graceful degradation strategy. Attempts primary operation, falls back to cached data on failure, returns degraded response with warning, logs degradation event for monitoring.", "reply": "api context=/inventory name=InventoryAPI resource methods=GET uri-template=/{itemId} inSequence http.get configKey=InventoryService relativePath /items/${params.pathParams.itemId} headers [] respond faultSequence log category=WARN message Primary inventory service failed, using cached data: ${props.synapse.ERROR_MESSAGE} variable name=cachedData type=STRING expression=${registry('gov:/cache/inventory/' + params.pathParams.itemId)} filter xpath=${exists(vars.cachedData)} then payloadFactory media-type=json format {\"data\":${vars.cachedData},\"source\":\"cache\",\"warning\":\"Live data unavailable, serving cached response\",\"cacheAge\":3600} header name=HTTP_SC value=200 scope=axis2 else payloadFactory media-type=json format {\"error\":\"Service unavailable and no cached data available\"} header name=HTTP_SC value=503 scope=axis2 respond"}
{"description": "Basic error response with standard JSON format. Simple fault sequence that returns error message and code in consistent structure with 500 status, suitable for uniform error handling.", "reply": "sequence name=StandardErrorResponse payloadFactory media-type=json format {\"status\":\"error\",\"code\":\"${props.synapse.ERROR_CODE}\",\"message\":\"${props.synapse.ERROR_MESSAGE}\"} header name=HTTP_SC value=500 scope=axis2 respond"}
{"description": "HTTP connector initialization with basic authentication for external REST API integration. Configures connection pooling, timeout of 30 seconds, and retry logic with exponential backoff for transient failures.", "reply": "localEntry key=ExternalAPIConn http.init connectionType https baseUrl https://api.example.com authType Basic Auth basicCredentialsUsername apiuser basicCredentialsPassword SecureP@ssw0rd timeoutDuration 30 timeoutAction Never retryErrorCodes 500,502,503 retryCount 3 retryDelay 5 suspendErrorCodes 404 suspendInitialDuration 10 suspendProgressionFactor 2 suspendMaximumDuration 60000 name ExternalAPIConn"}
{"description": "Simple HTTP GET request using connector to retrieve user data from REST endpoint. Passes dynamic user ID from variable in relative path and sets custom content-type header.", "reply": "http.get configKey=ExternalAPIConn relativePath /users/${vars.userId} headers [[\"Content-Type\",\"application/json\"],[\"Accept\",\"application/json\"]] forceScAccepted false disableChunking false forceHttp10 false noKeepAlive false forcePostPutNobody false forceHttpContentLength false"}
{"description": "HTTP POST operation with JSON payload transformation. Sends order data to payment gateway using connector, including custom authorization header and dynamic request body from payload.", "reply": "http.post configKey=PaymentGatewayConn relativePath /process-payment headers [[\"Authorization\",\"Bearer ${vars.accessToken}\"],[\"X-Request-ID\",\"${vars.requestId}\"]] requestBodyType JSON requestBodyJson ${payload} forceScAccepted false disableChunking false forceHttp10 false noKeepAlive false forcePostPutNobody false forceHttpContentLength false"}
{"description": "API resource that integrates external weather service using HTTP connector with query parameters. Extracts city from path parameter, calls weather API, and logs response before returning to client.", "reply": "api name=WeatherAPI context=/weather resource methods=GET uri-template=/{city} inSequence variable name=city expression=${params.pathParams.city} type=STRING http.get configKey=WeatherServiceConn relativePath /current?q=${vars.city}&appid=abc123key headers [[\"Accept\",\"application/json\"]] forceScAccepted false disableChunking false forceHttp10 false noKeepAlive false forcePostPutNobody false forceHttpContentLength false log category=INFO message Weather data: ${payload} respond"}
{"description": "HTTP connector with OAuth 2.0 bearer token authentication for secure API integration. Includes connection timeout configuration, custom user-agent header, and automatic retry for server errors.", "reply": "localEntry key=SecureAPIConn http.init connectionType https baseUrl https://secure-api.company.com authType No Auth timeoutDuration 45 timeoutAction Never retryErrorCodes 500,503,504 retryCount 2 retryDelay 3 suspendErrorCodes 401,403 suspendInitialDuration 5 suspendProgressionFactor 1 suspendMaximumDuration 30000 name SecureAPIConn"}
{"description": "HTTP PUT request to update customer profile. Uses connector with XML request body transformation, includes correlation ID header for tracking, and enables chunked transfer encoding.", "reply": "http.put configKey=CustomerServiceConn relativePath /customers/${vars.customerId} headers [[\"Content-Type\",\"application/xml\"],[\"X-Correlation-ID\",\"${vars.correlationId}\"]] requestBodyType XML requestBodyXml {${xpath('$body/node()')}} forceScAccepted false disableChunking false forceHttp10 false noKeepAlive false forcePostPutNobody false forceHttpContentLength true"}
{"description": "Service orchestration pattern calling multiple backend services sequentially. First retrieves user profile, then fetches related orders using HTTP connector, aggregates data with payload factory, and responds.", "reply": "api name=UserOrdersAPI context=/user-orders resource methods=GET uri-template=/{userId} inSequence variable name=userId expression=${params.pathParams.userId} type=STRING http.get configKey=UserServiceConn relativePath /users/${vars.userId} headers [[\"Accept\",\"application/json\"]] forceScAccepted false variable name=userName expression=${payload.name} type=STRING http.get configKey=OrderServiceConn relativePath /orders?userId=${vars.userId} headers [[\"Accept\",\"application/json\"]] forceScAccepted false payloadFactory media-type=json format {\"user\":\"${vars.userName}\",\"orders\":${payload}} respond"}
{"description": "HTTP DELETE operation with API key authentication in header. Removes resource by ID from external service using connector, includes custom headers for tracking and audit.", "reply": "http.delete configKey=ResourceServiceConn relativePath /resources/${vars.resourceId} headers [[\"X-API-Key\",\"sk_live_abc123xyz789\"],[\"X-Idempotency-Key\",\"${vars.idempotencyKey}\"],[\"User-Agent\",\"WSO2-MI/4.3.0\"]] forceScAccepted false disableChunking false forceHttp10 false noKeepAlive false forcePostPutNobody false forceHttpContentLength false"}
{"description": "Conditional routing pattern based on HTTP response status. Calls inventory service, checks availability using filter mediator, then either processes order or returns out-of-stock message.", "reply": "api name=OrderProcessAPI context=/orders resource methods=POST inSequence variable name=productId expression=${payload.productId} type=STRING http.get configKey=InventoryServiceConn relativePath /inventory/${vars.productId} headers [[\"Accept\",\"application/json\"]] forceScAccepted false filter xpath=${payload.available == true} then http.post configKey=OrderServiceConn relativePath /create headers [[\"Content-Type\",\"application/json\"]] requestBodyType JSON requestBodyJson ${payload} forceScAccepted false respond else payloadFactory media-type=json format {\"error\":\"Out of stock\"} respond"}
{"description": "HTTP connector configuration with comprehensive retry and circuit breaker pattern. Suspends endpoint on authentication failures, implements progressive backoff, and handles connection pooling for high throughput.", "reply": "localEntry key=ResilientAPIConn http.init connectionType https baseUrl https://api.resilient-service.io authType Basic Auth basicCredentialsUsername integration_user basicCredentialsPassword P@ssw0rd!2024 timeoutDuration 60 timeoutAction Never retryErrorCodes 500,502,503,504,408 retryCount 5 retryDelay 10 suspendErrorCodes 401,403,429 suspendInitialDuration 30 suspendProgressionFactor 3 suspendMaximumDuration 300000 name ResilientAPIConn"}
{"description": "Parallel service invocation using scatter-gather mediator with HTTP connector. Simultaneously calls pricing and availability services, aggregates JSON responses, and returns consolidated product information.", "reply": "api name=ProductAggregationAPI context=/products resource methods=GET uri-template=/{productId} inSequence variable name=productId expression=${params.pathParams.productId} type=STRING scatter-gather parallel-execution=true target=Body result-content-type=JSON aggregation expression=${payload} sequence http.get configKey=PricingServiceConn relativePath /prices/${vars.productId} headers [[\"Accept\",\"application/json\"]] forceScAccepted false sequence http.get configKey=InventoryServiceConn relativePath /availability/${vars.productId} headers [[\"Accept\",\"application/json\"]] forceScAccepted false respond"}
{"description": "HTTP PATCH operation for partial resource updates. Uses connector to send incremental changes to user service with JSON merge patch content type and optimistic concurrency control via ETag header.", "reply": "http.patch configKey=UserServiceConn relativePath /users/${vars.userId} headers [[\"Content-Type\",\"application/merge-patch+json\"],[\"If-Match\",\"${vars.etag}\"],[\"X-Client-Version\",\"2.1.0\"]] requestBodyType JSON requestBodyJson ${payload} forceScAccepted false disableChunking false forceHttp10 false noKeepAlive false forcePostPutNobody false forceHttpContentLength true"}
{"description": "Webhook receiver that forwards notifications to external system using HTTP POST connector. Validates incoming payload, enriches with metadata, and sends to notification service with custom headers.", "reply": "api name=WebhookForwarder context=/webhook resource methods=POST inSequence variable name=eventType expression=${payload.event} type=STRING variable name=timestamp expression=${now()} type=STRING payloadFactory media-type=json format {\"event\":\"${vars.eventType}\",\"timestamp\":${vars.timestamp},\"data\":${payload}} http.post configKey=NotificationServiceConn relativePath /webhooks/inbound headers [[\"Content-Type\",\"application/json\"],[\"X-Webhook-Source\",\"WSO2-MI\"],[\"X-Event-Type\",\"${vars.eventType}\"]] requestBodyType JSON requestBodyJson ${payload} forceScAccepted false respond"}
{"description": "HTTP connector integration with error handling and fault sequence. Attempts service call with timeout, catches failures, logs errors, and returns standardized error response to client.", "reply": "api name=SafeServiceCall context=/safe-call resource methods=POST inSequence http.post configKey=ExternalServiceConn relativePath /process headers [[\"Content-Type\",\"application/json\"]] requestBodyType JSON requestBodyJson ${payload} forceScAccepted false respond faultSequence log category=ERROR message Service call failed: ${props.synapse.ERROR_MESSAGE} payloadFactory media-type=json format {\"error\":\"Service unavailable\",\"code\":\"${props.synapse.ERROR_CODE}\"} header name=HTTP_SC scope=default value=503 respond"}
{"description": "API key based authentication pattern with HTTP connector. Extracts API key from request header, validates against registry configuration, then forwards authenticated request to backend service.", "reply": "api name=AuthProxyAPI context=/api-proxy resource methods=POST uri-template=/data inSequence variable name=apiKey expression=${headers['X-API-Key']} type=STRING filter xpath=${vars.apiKey == 'sk_prod_abc123xyz'} then http.post configKey=BackendServiceConn relativePath /secure/data headers [[\"Content-Type\",\"application/json\"],[\"Authorization\",\"Bearer internal_token_xyz\"]] requestBodyType JSON requestBodyJson ${payload} forceScAccepted false respond else payloadFactory media-type=json format {\"error\":\"Unauthorized\"} header name=HTTP_SC scope=default value=401 respond"}
{"description": "HTTP OPTIONS request for CORS preflight handling. Queries service capabilities using connector, returns allowed methods and headers to client with appropriate CORS response headers.", "reply": "http.options configKey=ServiceDiscoveryConn relativePath /api/capabilities headers [[\"Accept\",\"application/json\"],[\"Origin\",\"https://app.example.com\"]] forceScAccepted false disableChunking false forceHttp10 false noKeepAlive false forcePostPutNobody false forceHttpContentLength false"}
{"description": "Rate limiting integration using HTTP connector to check quota service. Validates request count against external rate limiter, enforces throttling policy, and returns 429 status when limit exceeded.", "reply": "api name=RateLimitedAPI context=/limited resource methods=GET inSequence variable name=clientId expression=${headers['X-Client-ID']} type=STRING http.get configKey=RateLimiterConn relativePath /check?client=${vars.clientId} headers [[\"Accept\",\"application/json\"]] forceScAccepted false filter xpath=${payload.allowed == true} then http.get configKey=DataServiceConn relativePath /data headers [[\"Accept\",\"application/json\"]] forceScAccepted false respond else payloadFactory media-type=json format {\"error\":\"Rate limit exceeded\"} header name=HTTP_SC scope=default value=429 respond"}
{"description": "Content-based routing with HTTP connector integration. Evaluates payload fields using switch mediator, routes to different backend services based on message type, includes fallback endpoint.", "reply": "api name=SmartRouter context=/route resource methods=POST inSequence variable name=messageType expression=${payload.type} type=STRING switch source=${vars.messageType} case regex=order http.post configKey=OrderServiceConn relativePath /orders headers [[\"Content-Type\",\"application/json\"]] requestBodyType JSON requestBodyJson ${payload} forceScAccepted false case regex=payment http.post configKey=PaymentServiceConn relativePath /payments headers [[\"Content-Type\",\"application/json\"]] requestBodyType JSON requestBodyJson ${payload} forceScAccepted false default http.post configKey=DefaultServiceConn relativePath /process headers [[\"Content-Type\",\"application/json\"]] requestBodyType JSON requestBodyJson ${payload} forceScAccepted false respond"}
{"description": "Batch processing with foreach mediator and HTTP connector. Iterates through array of records, sends individual POST requests to processing service, collects results, and aggregates final response.", "reply": "api name=BatchProcessor context=/batch resource methods=POST inSequence variable name=results type=STRING value=[] foreach expression=${payload.items} id=batchLoop sequence http.post configKey=ProcessingServiceConn relativePath /process-item headers [[\"Content-Type\",\"application/json\"]] requestBodyType JSON requestBodyJson ${payload} forceScAccepted false log category=INFO message Processed item: ${payload.id} payloadFactory media-type=json format {\"status\":\"completed\",\"processed\":${length(payload.items)}} respond"}
{"description": "HTTP HEAD request for resource metadata retrieval. Uses connector to check file existence and size without downloading content, optimizes bandwidth by fetching only headers from storage service.", "reply": "http.head configKey=StorageServiceConn relativePath /files/${vars.fileId}/metadata headers [[\"Accept\",\"application/json\"],[\"X-Request-ID\",\"${vars.requestId}\"]] forceScAccepted false disableChunking false forceHttp10 false noKeepAlive false forcePostPutNobody false forceHttpContentLength false"}
{"description": "HTTP inbound endpoint configuration listening on port 8081 with sequential message processing enabled. Routes incoming requests to ProcessOrderSequence for order validation and processing with error handling configured.", "reply": "inboundEndpoint name=HttpOrderEndpoint sequence=ProcessOrderSequence onError=OrderFaultSequence protocol=http suspend=false parameters parameter name=inbound.http.port 8081 parameter name=sequential true"}
{"description": "File inbound endpoint using VFS transport to poll directory /data/input every 5000ms for CSV files. Moves processed files to /data/archive and failed files to /data/error. Sequential processing ensures ordered file handling.", "reply": "inboundEndpoint name=FilePollingEndpoint sequence=FileProcessSequence onError=FileErrorSequence protocol=file suspend=false parameters parameter name=interval 5000 parameter name=transport.vfs.FileURI file:///data/input parameter name=transport.vfs.ContentType text/csv parameter name=transport.vfs.FileNamePattern .*\\.csv parameter name=transport.vfs.ActionAfterProcess MOVE parameter name=transport.vfs.MoveAfterProcess file:///data/archive parameter name=transport.vfs.MoveAfterFailure file:///data/error parameter name=sequential true"}
{"description": "JMS inbound endpoint consuming messages from OrderQueue with connection factory QueueConnectionFactory. Implements error handling and sequential processing for guaranteed message ordering in order processing workflow.", "reply": "inboundEndpoint name=JmsOrderConsumer sequence=ProcessJmsOrderSequence onError=JmsErrorSequence protocol=jms suspend=false parameters parameter name=interval 2000 parameter name=transport.jms.Destination OrderQueue parameter name=transport.jms.ConnectionFactoryJNDIName QueueConnectionFactory parameter name=java.naming.factory.initial org.apache.activemq.jndi.ActiveMQInitialContextFactory parameter name=java.naming.provider.url tcp://localhost:61616 parameter name=sequential true"}
{"description": "MQTT inbound endpoint subscribing to iot/sensors/temperature topic with QoS 2 for guaranteed delivery. Processes IoT sensor data through SensorDataSequence with reconnection parameters and clean session disabled for persistent subscriptions.", "reply": "inboundEndpoint name=MqttSensorEndpoint sequence=SensorDataSequence onError=MqttErrorSequence protocol=mqtt suspend=false parameters parameter name=mqtt.connection.factory mqttFactory parameter name=mqtt.server.host.name tcp://localhost:1883 parameter name=mqtt.topic.name iot/sensors/temperature parameter name=mqtt.subscription.qos 2 parameter name=mqtt.client.id mi-sensor-client parameter name=mqtt.session.clean false parameter name=content.type application/json parameter name=sequential true"}
{"description": "Kafka inbound endpoint consuming messages from customer-events topic with consumer group mi-consumer-group. Configured for partition assignment, offset management, and sequential processing with custom deserializers for event stream processing.", "reply": "inboundEndpoint name=KafkaEventConsumer sequence=EventProcessingSequence onError=KafkaErrorSequence protocol=kafka suspend=false parameters parameter name=interval 1000 parameter name=coordination true parameter name=sequential true parameter name=topics customer-events parameter name=group.id mi-consumer-group parameter name=bootstrap.servers localhost:9092 parameter name=key.deserializer org.apache.kafka.common.serialization.StringDeserializer parameter name=value.deserializer org.apache.kafka.common.serialization.StringDeserializer parameter name=auto.offset.reset earliest"}
{"description": "HTTPS inbound endpoint with SSL configuration on port 8443 for secure API gateway. Uses keystore for SSL termination and routes authenticated requests to SecureAPISequence with worker pool size configuration for concurrent request handling.", "reply": "inboundEndpoint name=HttpsApiEndpoint sequence=SecureAPISequence onError=HttpsErrorSequence protocol=https suspend=false parameters parameter name=inbound.http.port 8443 parameter name=keystore /repository/resources/security/wso2carbon.jks parameter name=keystorePass wso2carbon parameter name=truststore /repository/resources/security/client-truststore.jks parameter name=truststorePass wso2carbon parameter name=inbound.worker.pool.size.core 400 parameter name=inbound.worker.pool.size.max 500"}
{"description": "File inbound endpoint with SFTP protocol monitoring remote directory for XML invoice files. Implements passive mode FTP, custom polling interval of 10 seconds, and automatic file locking to prevent concurrent processing of same file.", "reply": "inboundEndpoint name=SftpInvoiceEndpoint sequence=InvoiceProcessSequence onError=SftpErrorSequence protocol=file suspend=false parameters parameter name=interval 10000 parameter name=transport.vfs.FileURI sftp://user:pass@ftp.example.com/invoices parameter name=transport.vfs.ContentType application/xml parameter name=transport.vfs.FileNamePattern .*\\.xml parameter name=transport.vfs.FileLocking enable parameter name=transport.vfs.ActionAfterProcess DELETE parameter name=sequential true"}
{"description": "JMS inbound endpoint with transaction management consuming from PaymentQueue. Configures session transactions, acknowledgment mode, and cache level for reliable payment message processing with rollback on failure through error sequence.", "reply": "inboundEndpoint name=JmsPaymentEndpoint sequence=PaymentProcessSequence onError=PaymentErrorSequence protocol=jms suspend=false parameters parameter name=interval 3000 parameter name=transport.jms.Destination PaymentQueue parameter name=transport.jms.ConnectionFactoryJNDIName QueueConnectionFactory parameter name=java.naming.factory.initial org.apache.activemq.jndi.ActiveMQInitialContextFactory parameter name=java.naming.provider.url tcp://localhost:61616 parameter name=transport.jms.SessionTransacted true parameter name=transport.jms.SessionAcknowledgement SESSION_TRANSACTED parameter name=transport.jms.CacheLevel 3 parameter name=sequential true"}
{"description": "MQTT inbound endpoint with Last Will Testament configuration subscribing to device/status topic. Implements automatic reconnection with exponential backoff, connection timeout settings, and keep-alive interval for IoT device monitoring.", "reply": "inboundEndpoint name=MqttDeviceMonitor sequence=DeviceStatusSequence onError=MqttDeviceErrorSequence protocol=mqtt suspend=false parameters parameter name=mqtt.connection.factory mqttFactory parameter name=mqtt.server.host.name tcp://broker.example.com:1883 parameter name=mqtt.topic.name device/status parameter name=mqtt.subscription.qos 1 parameter name=mqtt.client.id mi-device-monitor parameter name=mqtt.session.clean false parameter name=mqtt.reconnection.interval 5000 parameter name=mqtt.connection.timeout 30 parameter name=mqtt.keep.alive 60"}
{"description": "Kafka inbound endpoint with multiple topic subscription pattern consuming from all order-related topics. Configures consumer properties including max poll records, heartbeat interval, and partition rebalancing strategy for distributed event processing.", "reply": "inboundEndpoint name=KafkaMultiTopicConsumer sequence=MultiTopicProcessSequence onError=KafkaMultiTopicErrorSequence protocol=kafka suspend=false parameters parameter name=interval 1000 parameter name=coordination true parameter name=sequential false parameter name=topic.pattern order-.* parameter name=group.id mi-multi-topic-group parameter name=bootstrap.servers kafka1:9092,kafka2:9092 parameter name=key.deserializer org.apache.kafka.common.serialization.StringDeserializer parameter name=value.deserializer org.apache.kafka.common.serialization.StringDeserializer parameter name=max.poll.records 100 parameter name=heartbeat.interval.ms 3000 parameter name=partition.assignment.strategy org.apache.kafka.clients.consumer.RoundRobinAssignor"}
{"description": "HTTP inbound endpoint with custom worker pool configuration and request size limits. Implements connection throttling, idle timeout, and dispatches to routing sequence based on URL patterns for high-throughput API gateway scenario.", "reply": "inboundEndpoint name=HttpGatewayEndpoint sequence=ApiRoutingSequence onError=GatewayErrorSequence protocol=http suspend=false parameters parameter name=inbound.http.port 8280 parameter name=inbound.worker.pool.size.core 200 parameter name=inbound.worker.pool.size.max 400 parameter name=inbound.worker.thread.keep.alive.sec 60 parameter name=inbound.worker.pool.queue.length -1 parameter name=inbound.thread.id httpGatewayWorker"}
{"description": "File inbound endpoint monitoring FTP directory with content-based routing. Polls every 15 seconds for JSON and XML files, implements file sorting by timestamp, and uses move-after-process pattern with timestamped archive directories.", "reply": "inboundEndpoint name=FtpPollingEndpoint sequence=FileRoutingSequence onError=FtpErrorSequence protocol=file suspend=false parameters parameter name=interval 15000 parameter name=transport.vfs.FileURI ftp://ftpuser:ftppass@ftp.example.com/data parameter name=transport.vfs.ContentType application/octet-stream parameter name=transport.vfs.FileNamePattern .*(json|xml)$ parameter name=transport.vfs.FileSortAttribute lastmodified parameter name=transport.vfs.FileSortAscending true parameter name=transport.vfs.ActionAfterProcess MOVE parameter name=transport.vfs.MoveAfterProcess ftp://ftpuser:ftppass@ftp.example.com/archive parameter name=transport.vfs.MoveTimestampFormat yyyy-MM-dd-HH-mm-ss parameter name=sequential true"}
{"description": "JMS inbound endpoint with message selector filtering high-priority orders. Implements durable subscription, prefetch policy configuration, and concurrent consumer support for parallel processing of filtered messages from TopicConnection.", "reply": "inboundEndpoint name=JmsPriorityOrderEndpoint sequence=PriorityOrderSequence onError=JmsPriorityErrorSequence protocol=jms suspend=false parameters parameter name=interval 2000 parameter name=transport.jms.Destination OrderTopic parameter name=transport.jms.ConnectionFactoryJNDIName TopicConnectionFactory parameter name=java.naming.factory.initial org.apache.activemq.jndi.ActiveMQInitialContextFactory parameter name=java.naming.provider.url tcp://localhost:61616 parameter name=transport.jms.SubscriptionDurable true parameter name=transport.jms.DurableSubscriberName priority-order-subscriber parameter name=transport.jms.MessageSelector priority='HIGH' parameter name=transport.jms.ConcurrentConsumers 5 parameter name=sequential false"}
{"description": "MQTT inbound endpoint with SSL/TLS configuration subscribing to secure telemetry data topic. Implements certificate-based authentication, custom quality of service level 1, and message persistence for reliable IoT data ingestion pipeline.", "reply": "inboundEndpoint name=SecureMqttTelemetryEndpoint sequence=TelemetryProcessSequence onError=MqttTelemetryErrorSequence protocol=mqtt suspend=false parameters parameter name=mqtt.connection.factory secureMqttFactory parameter name=mqtt.server.host.name ssl://secure-broker.example.com:8883 parameter name=mqtt.topic.name telemetry/data/# parameter name=mqtt.subscription.qos 1 parameter name=mqtt.client.id mi-telemetry-client parameter name=mqtt.session.clean false parameter name=mqtt.ssl.enable true parameter name=mqtt.ssl.keystore.location /security/keystore.jks parameter name=mqtt.ssl.keystore.password keystorepass parameter name=mqtt.ssl.truststore.location /security/truststore.jks parameter name=mqtt.ssl.truststore.password truststorepass parameter name=content.type application/json parameter name=sequential true"}
{"description": "Kafka inbound endpoint with SASL authentication and SSL encryption consuming from financial-transactions topic. Configures security protocol, commit interval, and exactly-once semantics for critical financial data processing with transaction isolation.", "reply": "inboundEndpoint name=SecureKafkaFinanceEndpoint sequence=FinanceTransactionSequence onError=KafkaFinanceErrorSequence protocol=kafka suspend=false parameters parameter name=interval 500 parameter name=coordination true parameter name=sequential true parameter name=topics financial-transactions parameter name=group.id mi-finance-group parameter name=bootstrap.servers kafka-secure.example.com:9093 parameter name=security.protocol SASL_SSL parameter name=sasl.mechanism PLAIN parameter name=sasl.jaas.config org.apache.kafka.common.security.plain.PlainLoginModule required username=\"admin\" password=\"secret\"; parameter name=key.deserializer org.apache.kafka.common.serialization.StringDeserializer parameter name=value.deserializer org.apache.kafka.common.serialization.StringDeserializer parameter name=enable.auto.commit false parameter name=isolation.level read_committed"}
{"description": "HTTP WebSocket inbound endpoint on port 9091 for real-time bidirectional communication. Configures subprotocols, outflow dispatch sequence for client messages, and boss/worker thread groups for scalable WebSocket server implementation.", "reply": "inboundEndpoint name=WebSocketEndpoint sequence=WebSocketInboundSequence onError=WebSocketErrorSequence protocol=ws suspend=false parameters parameter name=inbound.ws.port 9091 parameter name=ws.client.side.broadcast.level 0 parameter name=ws.outflow.dispatch.sequence WebSocketOutflowSequence parameter name=ws.outflow.dispatch.fault.sequence WebSocketOutflowFaultSequence parameter name=ws.boss.thread.pool.size 2 parameter name=ws.worker.thread.pool.size 4"}
{"description": "File inbound endpoint with SMB protocol accessing Windows network share. Implements domain authentication, file age filtering to process files older than 5 minutes, and dynamic filename processing with regex pattern matching for compliance documents.", "reply": "inboundEndpoint name=SmbComplianceEndpoint sequence=ComplianceDocSequence onError=SmbErrorSequence protocol=file suspend=false parameters parameter name=interval 20000 parameter name=transport.vfs.FileURI smb://DOMAIN;username:password@fileserver/compliance parameter name=transport.vfs.ContentType application/pdf parameter name=transport.vfs.FileNamePattern ^COMP_\\d{8}_.*\\.pdf$ parameter name=transport.vfs.FileProcessInterval 300000 parameter name=transport.vfs.ActionAfterProcess MOVE parameter name=transport.vfs.MoveAfterProcess smb://DOMAIN;username:password@fileserver/processed parameter name=transport.vfs.CreateFolder true parameter name=sequential true"}
{"description": "JMS inbound endpoint with dead letter queue configuration consuming from NotificationQueue. Implements retry logic with maximum redelivery attempts, exponential backoff delay, and automatic routing to DLQ after exhausting retries for failed notification processing.", "reply": "inboundEndpoint name=JmsNotificationDlqEndpoint sequence=NotificationProcessSequence onError=NotificationDlqSequence protocol=jms suspend=false parameters parameter name=interval 2000 parameter name=transport.jms.Destination NotificationQueue parameter name=transport.jms.ConnectionFactoryJNDIName QueueConnectionFactory parameter name=java.naming.factory.initial org.apache.activemq.jndi.ActiveMQInitialContextFactory parameter name=java.naming.provider.url tcp://localhost:61616 parameter name=transport.jms.SessionTransacted true parameter name=transport.jms.ReconnectInterval 5000 parameter name=transport.jms.MaxRedeliveryAttempts 3 parameter name=transport.jms.InitialRedeliveryDelay 1000 parameter name=transport.jms.RedeliveryDelay 2000 parameter name=transport.jms.BackOffMultiplier 2 parameter name=sequential true"}
{"description": "MQTT inbound endpoint with dynamic topic subscription using wildcard patterns for multi-level hierarchical topics. Configures automatic subscription management, message buffer size, and implements filtering based on retained message flag for real-time analytics.", "reply": "inboundEndpoint name=MqttDynamicTopicEndpoint sequence=DynamicTopicProcessSequence onError=MqttDynamicErrorSequence protocol=mqtt suspend=false parameters parameter name=mqtt.connection.factory mqttFactory parameter name=mqtt.server.host.name tcp://mqtt.example.com:1883 parameter name=mqtt.topic.name analytics/+/events/# parameter name=mqtt.subscription.qos 1 parameter name=mqtt.client.id mi-dynamic-analytics parameter name=mqtt.session.clean false parameter name=mqtt.max.inflight 1000 parameter name=mqtt.message.buffer.size 5120 parameter name=mqtt.automatic.reconnect true parameter name=content.type application/json parameter name=sequential false"}
{"description": "Kafka inbound endpoint with custom interceptor chain for message transformation and auditing. Configures consumer interceptor classes, session timeout, fetch size optimization, and implements manual offset commit strategy for controlled message processing and replay capability.", "reply": "inboundEndpoint name=KafkaInterceptorEndpoint sequence=InterceptedMessageSequence onError=KafkaInterceptorErrorSequence protocol=kafka suspend=false parameters parameter name=interval 1000 parameter name=coordination true parameter name=sequential false parameter name=topics audit-events parameter name=group.id mi-audit-consumer parameter name=bootstrap.servers localhost:9092 parameter name=key.deserializer org.apache.kafka.common.serialization.StringDeserializer parameter name=value.deserializer org.apache.kafka.common.serialization.StringDeserializer parameter name=enable.auto.commit false parameter name=session.timeout.ms 30000 parameter name=fetch.min.bytes 1024 parameter name=fetch.max.wait.ms 500 parameter name=max.partition.fetch.bytes 1048576 parameter name=consumer.interceptor.classes com.example.AuditInterceptor"}
{"description": "Foreach mediator iterating over JSON array to process each order item individually, extracting item details and logging them sequentially for order processing workflow", "reply": "api context=/orders name=ProcessOrdersAPI resource methods=POST inSequence foreach expression=${payload.orders} sequence log category=INFO message Processing order: ${payload.orderId} - ${payload.itemName} respond"}
{"description": "Scatter-gather pattern using scatter-gather mediator to invoke multiple backend services in parallel and aggregate JSON responses into unified result set with timeout configuration", "reply": "api context=/aggregated name=ScatterGatherAPI resource methods=GET inSequence scatter-gather parallel-execution=true target=Body result-content-type=JSON aggregation expression=${payload} timeout=5000 sequence http.get configKey=ServiceA relativePath /data sequence http.get configKey=ServiceB relativePath /info respond"}
{"description": "Foreach mediator processing XML array of customer records, transforming each record using payloadFactory and enriching with additional data before storing results", "reply": "sequence name=ProcessCustomersSequence foreach expression=${xpath('//customers/customer')} sequence variable name=customerId expression=${xpath('//customer/id/text()')} payloadFactory media-type=json format {\"id\": \"${vars.customerId}\", \"status\": \"processed\"} log category=INFO message Customer ${vars.customerId} processed"}
{"description": "Batch processing implementation using foreach mediator to iterate product inventory array, validate stock levels, and invoke backend API for each item requiring restock", "reply": "api context=\"/inventory\" name=\"BatchInventoryAPI\" xmlns=\"http://ws.apache.org/ns/synapse\" resource methods=\"POST\" inSequence foreach expression=\"${payload.products}\" sequence filter xpath=\"${payload.stock 10}\" then http.post configKey=\"RestockService\" relativePath /restock requestBodyType JSON requestBodyJson ${payload} respond"}
{"description": "Parallel message handling with scatter-gather mediator executing three sequences simultaneously, each calling different microservice endpoint and combining responses into single JSON array", "reply": "api context=/parallel name=ParallelProcessingAPI resource methods=GET inSequence scatter-gather parallel-execution=true target=Body result-content-type=JSON aggregation expression=${payload} sequence http.get configKey=UserService relativePath /users/${params.queryParams.id} sequence http.get configKey=OrderService relativePath /orders/${params.queryParams.id} sequence http.get configKey=PaymentService relativePath /payments/${params.queryParams.id} respond"}
{"description": "Simple foreach iteration over JSON transactions array with logging mediator for audit trail generation in financial processing workflow", "reply": "sequence name=AuditTransactions foreach expression=${payload.transactions} sequence log category=INFO message Transaction ID: ${payload.txnId}, Amount: ${payload.amount}"}
{"description": "Foreach mediator processing email notifications array, using variable mediator to extract recipient details and invoking email service for each entry with error handling", "reply": "api context=/notifications name=EmailNotificationAPI resource methods=POST inSequence foreach expression=${payload.emails} sequence variable name=recipient expression=${payload.to} type=STRING variable name=subject expression=${payload.subject} type=STRING http.post configKey=EmailService relativePath /send requestBodyType JSON requestBodyJson ${payload} respond faultSequence log category=ERROR message Email sending failed: ${props.synapse.ERROR_MESSAGE} drop"}
{"description": "Message splitting pattern using foreach mediator on shipment items, enriching each item with tracking information from external API and collecting results for aggregated response", "reply": "sequence name=EnrichShipments foreach expression=${payload.shipments} sequence variable name=trackingId expression=${payload.trackingNumber} type=STRING http.get configKey=TrackingService relativePath /track?id=${vars.trackingId} payloadFactory media-type=json format {\"shipmentId\": \"${vars.trackingId}\", \"trackingData\": ${payload}}"}
{"description": "Scatter-gather mediator for parallel database lookups across multiple data sources, aggregating customer profile information with min-messages condition for partial responses", "reply": "api context=/customer name=CustomerAggregatorAPI resource methods=GET uri-template=/{id} inSequence scatter-gather parallel-execution=true target=Body result-content-type=JSON aggregation expression=${payload} timeout=3000 min-messages=2 sequence dblookup connection pool driver com.mysql.jdbc.Driver url jdbc:mysql://localhost:3306/profiles user dbuser password dbpass statement sql SELECT * FROM customer_profile WHERE id = ? parameter expression=${params.pathParams.id} type=VARCHAR result name=profile column=data sequence http.get configKey=PreferencesService relativePath /prefs/${params.pathParams.id} respond"}
{"description": "Foreach mediator implementing batch update pattern, iterating through user records array and executing database update for each record with transaction handling", "reply": "sequence name=BatchUpdateUsers foreach expression=${payload.users} sequence variable name=userId expression=${payload.id} type=INTEGER variable name=status expression=${payload.status} type=STRING dbreport connection pool driver com.mysql.jdbc.Driver url jdbc:mysql://localhost:3306/userdb user admin password admin123 statement sql UPDATE users SET status = ? WHERE id = ? parameter expression=${vars.status} type=VARCHAR parameter expression=${vars.userId} type=INTEGER"}
{"description": "Parallel execution pattern with scatter-gather mediator calling multiple REST endpoints with different payloads, aggregating results with conditional expression for filtering responses", "reply": "api context=/search name=ParallelSearchAPI resource methods=POST inSequence variable name=query expression=${payload.searchQuery} type=STRING scatter-gather parallel-execution=true target=Body result-content-type=JSON aggregation expression=${payload[?(@.count > 0)]} sequence http.get configKey=ProductService relativePath /search?q=${vars.query} sequence http.get configKey=ReviewService relativePath /search?q=${vars.query} respond"}
{"description": "Foreach iteration processing payment transactions with filter mediator for conditional routing, approved transactions sent to settlement service while rejected ones logged separately", "reply": "api context=/payments name=ProcessPaymentsAPI resource methods=POST inSequence foreach expression=${payload.payments} sequence filter xpath=${payload.status == 'approved'} then http.post configKey=SettlementService relativePath /settle requestBodyType JSON requestBodyJson ${payload} else log category=WARN message Rejected payment: ${payload.transactionId} respond"}
{"description": "Simple scatter-gather pattern aggregating responses from two microservices with timeout handling for resilient API composition in microservices architecture", "reply": "api context=/aggregate name=SimpleAggregateAPI resource methods=GET inSequence scatter-gather parallel-execution=true target=Body result-content-type=JSON aggregation expression=${payload} timeout=2000 sequence http.get configKey=ServiceOne relativePath /api/data sequence http.get configKey=ServiceTwo relativePath /api/info respond"}
{"description": "Foreach mediator iterating XML document nodes for order line items, calculating totals and invoking inventory service to check availability for each SKU with validation", "reply": "sequence name=ValidateOrderItems foreach expression=${xpath('//order/lineItems/item')} sequence variable name=sku expression=${xpath('//item/sku/text()')} variable name=quantity expression=${xpath('//item/quantity/text()')} type=INTEGER http.get configKey=InventoryService relativePath /check?sku=${vars.sku}&qty=${vars.quantity} filter xpath=${payload.available == true} then log category=INFO message SKU ${vars.sku} available"}
{"description": "Message aggregation using scatter-gather mediator to query multiple analytics services in parallel, combining metrics data with max-messages limit for performance optimization", "reply": "api context=/analytics name=MetricsAggregatorAPI resource methods=GET inSequence scatter-gather parallel-execution=true target=Body result-content-type=JSON aggregation expression=${payload} timeout=4000 max-messages=3 sequence http.get configKey=SalesMetrics relativePath /metrics/sales sequence http.get configKey=TrafficMetrics relativePath /metrics/traffic sequence http.get configKey=ConversionMetrics relativePath /metrics/conversion respond"}
{"description": "Batch processing workflow using foreach mediator to process invoice records, enriching each with tax calculations and generating PDF documents via external service", "reply": "sequence name=GenerateInvoices foreach expression=${payload.invoices} sequence variable name=invoiceId expression=${payload.id} type=STRING variable name=amount expression=${payload.amount} type=DOUBLE variable name=taxAmount expression=${vars.amount * 0.18} type=DOUBLE payloadFactory media-type=json format {\"invoiceId\": \"${vars.invoiceId}\", \"amount\": ${vars.amount}, \"tax\": ${vars.taxAmount}} http.post configKey=PDFService relativePath /generate requestBodyType JSON requestBodyJson ${payload}"}
{"description": "Foreach loop processing array of notification events, using switch mediator for routing based on event type and invoking appropriate notification channel service", "reply": "api context=/events name=NotificationRouterAPI resource methods=POST inSequence foreach expression=${payload.events} sequence switch source=${payload.type} case regex=email http.post configKey=EmailGateway relativePath /send requestBodyType JSON requestBodyJson ${payload} case regex=sms http.post configKey=SMSGateway relativePath /send requestBodyType JSON requestBodyJson ${payload} default log category=WARN message Unknown event type: ${payload.type} respond"}
{"description": "Simple foreach iteration over JSON array logging each element for debugging and monitoring purposes in development environment", "reply": "sequence name=DebugArray foreach expression=${payload.items} sequence log category=DEBUG message ${payload}"}
{"description": "Parallel service orchestration using scatter-gather mediator to fetch user profile, preferences and activity history simultaneously, combining into enriched user context object", "reply": "api context=/user/context name=UserContextAPI resource methods=GET uri-template=/{userId} inSequence scatter-gather parallel-execution=true target=Body result-content-type=JSON aggregation expression=${payload} timeout=5000 sequence http.get configKey=ProfileService relativePath /profile/${params.pathParams.userId} sequence http.get configKey=PreferencesAPI relativePath /user/${params.pathParams.userId}/prefs sequence http.get configKey=ActivityService relativePath /activity/${params.pathParams.userId} respond"}
{"description": "Complex batch processing with foreach mediator iterating supplier orders, validating against business rules, transforming to internal format, persisting to database and sending confirmation via message queue", "reply": "api context=/suppliers/orders name=SupplierOrderBatchAPI resource methods=POST inSequence foreach expression=${payload.supplierOrders} sequence variable name=orderId expression=${payload.orderId} type=STRING variable name=supplierId expression=${payload.supplierId} type=STRING variable name=totalAmount expression=${payload.totalAmount} type=DOUBLE filter xpath=${vars.totalAmount > 1000} then payloadFactory media-type=json format {\"order_id\": \"${vars.orderId}\", \"supplier\": \"${vars.supplierId}\", \"amount\": ${vars.totalAmount}, \"status\": \"approved\"} dbreport connection pool driver com.mysql.jdbc.Driver url jdbc:mysql://localhost:3306/orders user orderuser password order123 statement sql INSERT INTO supplier_orders (order_id, supplier_id, amount, status) VALUES (?, ?, ?, 'approved') parameter expression=${vars.orderId} type=VARCHAR parameter expression=${vars.supplierId} type=VARCHAR parameter expression=${vars.totalAmount} type=DOUBLE log category=INFO message Order ${vars.orderId} processed and stored respond"}
{"description": "In-Memory message store configuration for storing messages temporarily in memory with a maximum size limit. Useful for lightweight message buffering without external dependencies.", "reply": "messageStore name=InMemoryStore class=org.apache.synapse.message.store.impl.memory.InMemoryStore parameter name=store.producer.guaranteed.delivery.enable false parameter name=store.failover.message.store.name FailoverStore"}
{"description": "Scheduled message forwarding processor with In-Memory store for guaranteed message delivery. Processes messages every 10 seconds with retry mechanism and dead letter channel configuration.", "reply": "messageProcessor name=ScheduledProcessor class=org.apache.synapse.message.processor.impl.forwarder.ScheduledMessageForwardingProcessor targetEndpoint=OrderServiceEndpoint messageStore=InMemoryStore parameter name=interval 10000 parameter name=max.delivery.attempts 5 parameter name=client.retry.interval 3000 parameter name=max.delivery.drop Disabled parameter name=member.count 1"}
{"description": "JMS message store with ActiveMQ broker for persistent message storage. Configured with connection factory and queue destination for reliable asynchronous messaging patterns.", "reply": "messageStore name=JMSStore class=org.apache.synapse.message.store.impl.jms.JmsStore parameter name=java.naming.factory.initial org.apache.activemq.jndi.ActiveMQInitialContextFactory parameter name=java.naming.provider.url tcp://localhost:61616 parameter name=store.jms.destination OrderQueue parameter name=store.jms.connection.factory QueueConnectionFactory parameter name=store.jms.JMSSpecVersion 1.1"}
{"description": "Message sampling processor for JMS store that samples and forwards messages to monitoring endpoint. Processes one message per cycle with configurable sequence for custom logic execution.", "reply": "messageProcessor name=SamplingProcessor class=org.apache.synapse.message.processor.impl.sampler.SamplingProcessor messageStore=JMSStore parameter name=interval 5000 parameter name=sequence MonitoringSequence parameter name=is.active true parameter name=concurrency 1"}
{"description": "JDBC message store using MySQL database for persistent message storage. Configured with connection pool settings and database driver for enterprise-grade message durability and recovery.", "reply": "messageStore name=JDBCStore class=org.apache.synapse.message.store.impl.jdbc.JDBCMessageStore parameter name=store.jdbc.driver com.mysql.jdbc.Driver parameter name=store.jdbc.connection.url jdbc:mysql://localhost:3306/messagedb parameter name=store.jdbc.username dbuser parameter name=store.jdbc.password dbpass123 parameter name=store.jdbc.table messages"}
{"description": "RabbitMQ message store configured with exchange and routing key for distributed message persistence. Supports AMQP protocol with connection retry and failover capabilities.", "reply": "messageStore name=RabbitMQStore class=org.apache.synapse.message.store.impl.rabbitmq.RabbitMQStore parameter name=store.rabbitmq.host.name localhost parameter name=store.rabbitmq.host.port 5672 parameter name=store.rabbitmq.queue.name OrderQueue parameter name=store.rabbitmq.exchange.name OrderExchange parameter name=store.rabbitmq.route.key order.routing parameter name=rabbitmq.connection.ssl.enabled false"}
{"description": "Store mediator implementation that sends messages to In-Memory message store for asynchronous processing. Enables fire-and-forget pattern with guaranteed delivery when combined with message processor.", "reply": "store messageStore=InMemoryStore"}
{"description": "API with store mediator for asynchronous order processing. Stores incoming POST requests in message store and responds immediately, enabling non-blocking request handling with guaranteed delivery.", "reply": "api name=AsyncOrderAPI context=/orders resource methods=POST inSequence variable name=orderId expression=${payload.orderId} type=STRING log category=INFO message Storing order: ${vars.orderId} store messageStore=OrderStore faultSequence log category=ERROR message Order storage failed drop"}
{"description": "Scheduled message forwarding processor with exponential retry backoff. Configured to forward messages from JDBC store to backend endpoint with increasing retry intervals and maximum attempt limits.", "reply": "messageProcessor name=ExponentialRetryProcessor class=org.apache.synapse.message.processor.impl.forwarder.ScheduledMessageForwardingProcessor targetEndpoint=BackendService messageStore=JDBCStore parameter name=interval 5000 parameter name=max.delivery.attempts 10 parameter name=client.retry.interval 5000 parameter name=exponential.retry.multiplier 2.0 parameter name=maximum.retry.interval 60000"}
{"description": "RabbitMQ message store with SSL enabled and virtual host configuration. Implements secure message persistence with authentication for production environments requiring encrypted communication.", "reply": "messageStore name=SecureRabbitMQStore class=org.apache.synapse.message.store.impl.rabbitmq.RabbitMQStore parameter name=store.rabbitmq.host.name rabbitmq.example.com parameter name=store.rabbitmq.host.port 5671 parameter name=store.rabbitmq.queue.name SecureQueue parameter name=store.rabbitmq.username admin parameter name=store.rabbitmq.password securepass parameter name=rabbitmq.connection.ssl.enabled true parameter name=store.rabbitmq.virtual.host /production"}
{"description": "Message forwarding processor with dead letter channel and fault sequence. Failed messages after max retries are moved to error store with comprehensive error logging and notification.", "reply": "messageProcessor name=DLQProcessor class=org.apache.synapse.message.processor.impl.forwarder.ScheduledMessageForwardingProcessor targetEndpoint=PaymentEndpoint messageStore=PaymentStore parameter name=interval 8000 parameter name=max.delivery.attempts 3 parameter name=max.delivery.drop Enabled parameter name=message.processor.fault.sequence ErrorHandlerSequence parameter name=message.processor.deactivate.sequence DeactivateSequence"}
{"description": "In-Memory message store with guaranteed delivery enabled and failover configuration. Automatically switches to failover store when primary store encounters issues, ensuring message persistence.", "reply": "messageStore name=PrimaryStore class=org.apache.synapse.message.store.impl.memory.InMemoryStore parameter name=store.producer.guaranteed.delivery.enable true parameter name=store.failover.message.store.name BackupJDBCStore parameter name=store.producer.guaranteed.delivery.failover.message.store.enable true"}
{"description": "Sampling processor for monitoring and auditing messages without removal. Samples messages from JMS store every 15 seconds and executes custom auditing sequence for compliance tracking.", "reply": "messageProcessor name=AuditSamplingProcessor class=org.apache.synapse.message.processor.impl.sampler.SamplingProcessor messageStore=AuditJMSStore parameter name=interval 15000 parameter name=sequence AuditLoggingSequence parameter name=quartz.conf /conf/quartz.properties parameter name=cronExpression 0 0/5 * * * ?"}
{"description": "Store-and-forward pattern implementation with JMS store and scheduled processor. API stores messages for batch processing with HTTP endpoint configuration and connection pooling for high throughput.", "reply": "api name=\"BatchProcessingAPI\" context=\"/batch\" xmlns=\"http://ws.apache.org/ns/synapse\" resource methods=\"POST\" inSequence variable name=\"batchId\" expression=\"${payload.batchId}\" type=\"STRING\" log category=\"INFO\" message Batch ${vars.batchId} stored for processing store messageStore=\"BatchJMSStore\" messageProcessor name=\"BatchForwarder\" class=\"org.apache.synapse.message.processor.impl.forwarder.ScheduledMessageForwardingProcessor\" targetEndpoint=\"BatchProcessor\" messageStore=\"BatchJMSStore\" xmlns=\"http://ws.apache.org/ns/synapse\" parameter name=\"interval\" 30000 parameter name=\"max.delivery.attempts\" 5"}
{"description": "JDBC message store with PostgreSQL database and custom table schema. Configured with connection validation and transaction isolation level for enterprise message persistence with ACID properties.", "reply": "messageStore name=PostgresStore class=org.apache.synapse.message.store.impl.jdbc.JDBCMessageStore parameter name=store.jdbc.driver org.postgresql.Driver parameter name=store.jdbc.connection.url jdbc:postgresql://localhost:5432/messagedb parameter name=store.jdbc.username postgres parameter name=store.jdbc.password pgpass456 parameter name=store.jdbc.table synapse_messages parameter name=store.jdbc.connection.validation.query SELECT 1"}
{"description": "Message forwarding processor with throttling and concurrency control. Processes messages from RabbitMQ store with rate limiting to prevent backend service overload and resource exhaustion.", "reply": "messageProcessor name=ThrottledProcessor class=org.apache.synapse.message.processor.impl.forwarder.ScheduledMessageForwardingProcessor targetEndpoint=RateLimitedEndpoint messageStore=RabbitMQStore parameter name=interval 2000 parameter name=throttle true parameter name=throttle.threshold 100 parameter name=max.delivery.attempts 3 parameter name=member.count 2"}
{"description": "Complete store-and-forward integration with fault tolerance. API receives requests, stores in JDBC store, scheduled processor forwards with retry logic, and fault sequence handles errors with alerting.", "reply": "api name=ReliableProcessingAPI context=/reliable resource methods=POST inSequence variable name=requestId expression=${payload.requestId} type=STRING variable name=timestamp expression=${now()} type=STRING log category=INFO message Request ${vars.requestId} received at ${vars.timestamp} store messageStore=ReliableJDBCStore payloadFactory media-type=json format {\"status\":\"accepted\",\"requestId\":\"${vars.requestId}\"} respond faultSequence log category=ERROR message Storage failed: ${props.synapse.ERROR_MESSAGE} drop"}
{"description": "Multi-store configuration with primary In-Memory store and JDBC failover. Implements high-availability message storage pattern with automatic failover and guaranteed delivery across store types.", "reply": "messageStore name=\"HAMemoryStore\" class=\"org.apache.synapse.message.store.impl.memory.InMemoryStore\" xmlns=\"http://ws.apache.org/ns/synapse\" parameter name=\"store.producer.guaranteed.delivery.enable\" true parameter name=\"store.failover.message.store.name\" HAJDBCStore parameter name=\"store.producer.guaranteed.delivery.failover.message.store.enable\" true messageStore name=\"HAJDBCStore\" class=\"org.apache.synapse.message.store.impl.jdbc.JDBCMessageStore\" xmlns=\"http://ws.apache.org/ns/synapse\" parameter name=\"store.jdbc.driver\" com.mysql.jdbc.Driver parameter name=\"store.jdbc.connection.url\" jdbc:mysql://localhost:3306/hadb parameter name=\"store.jdbc.username\" hauser parameter name=\"store.jdbc.password\" hapass"}
{"description": "JMS message store with IBM MQ configuration for enterprise messaging. Implements queue manager connection with channel and CCSID settings for mainframe integration scenarios.", "reply": "messageStore name=IBMMQStore class=org.apache.synapse.message.store.impl.jms.JmsStore parameter name=java.naming.factory.initial com.ibm.mq.jms.MQQueueConnectionFactory parameter name=java.naming.provider.url localhost:1414 parameter name=store.jms.destination ENTERPRISE.QUEUE parameter name=store.jms.connection.factory MQConnectionFactory parameter name=store.jms.queue.manager QM1 parameter name=store.jms.channel SYSTEM.DEF.SVRCONN"}
{"description": "Advanced scheduled processor with Quartz cron expression for time-based message processing. Forwards messages during business hours only with custom error handling and dynamic endpoint resolution from message properties.", "reply": "messageProcessor name=CronScheduledProcessor class=org.apache.synapse.message.processor.impl.forwarder.ScheduledMessageForwardingProcessor targetEndpoint=BusinessHoursEndpoint messageStore=TimedJMSStore parameter name=cronExpression 0 0 9-17 ? * MON-FRI parameter name=max.delivery.attempts 7 parameter name=client.retry.interval 10000 parameter name=max.delivery.drop Enabled parameter name=message.processor.fault.sequence BusinessHoursFaultSeq parameter name=target.endpoint DynamicEndpoint parameter name=axis2.repo.repoPath /repository/deployment/server/"}
{"description": "JSON payload transformation using payloadFactory mediator to construct a customer order response with nested order details, customer ID, and total amount extracted from incoming payload using Synapse expressions", "reply": "api context=/orders name=OrderTransformAPI resource methods=POST uri-template=/create inSequence payloadFactory media-type=json format { \"orderId\": \"${payload.id}\", \"customer\": { \"customerId\": \"${payload.customerId}\", \"name\": \"${payload.customerName}\" }, \"orderTotal\": ${payload.amount}, \"status\": \"CONFIRMED\" } respond"}
{"description": "Header mediator configuration to add custom HTTP headers including correlation ID, timestamp, and authorization token to outbound service requests for distributed tracing and security", "reply": "sequence name=AddHeadersSequence header name=X-Correlation-ID value=${vars.correlationId} scope=transport header name=X-Request-Timestamp value=${now()} scope=transport header name=Authorization value=Bearer ${vars.authToken} scope=transport header name=Content-Type value=application/json scope=transport"}
{"description": "Enrich mediator pattern to augment incoming payload by adding user profile data from a variable into the message body as a new property without replacing existing content", "reply": "sequence name=EnrichUserDataSequence enrich source type=inline clone=true userProfile userId ${vars.userId} userName ${vars.userName} email ${vars.userEmail} target type=body action=child"}
{"description": "PayloadFactory mediator for XML to JSON transformation creating a product catalog response with array of items, prices, and availability status from XML backend service", "reply": "sequence name=ProductCatalogTransform payloadFactory media-type=json format { \"catalog\": { \"products\": [ { \"productId\": \"${xpath('//product/@id')}\", \"name\": \"${xpath('//product/name/text()')}\", \"price\": ${xpath('//product/price/text()')}, \"inStock\": ${xpath('//product/available/text()')} } ] } }"}
{"description": "Simple header removal pattern using header mediator to strip sensitive authentication headers and internal routing information before forwarding response to external clients", "reply": "sequence name=RemoveHeadersSequence header name=Authorization action=remove scope=transport header name=X-Internal-Route action=remove scope=transport header name=X-DB-Connection action=remove scope=transport"}
{"description": "PayloadFactory creating SOAP envelope with dynamic values for legacy web service integration, including authentication credentials and request parameters from incoming REST payload", "reply": "sequence name=SOAPEnvelopeBuilder payloadFactory media-type=xml format Envelope Header AuthHeader username ${vars.username} password ${vars.password} Body GetCustomer customerId ${payload.id}"}
{"description": "Enrich mediator extracting specific fields from incoming JSON payload and storing them as variables for subsequent processing, enabling data extraction without full payload replacement", "reply": "sequence name=ExtractFieldsSequence variable name=customerId expression=${payload.customer.id} type=STRING variable name=orderAmount expression=${payload.order.total} type=DOUBLE variable name=orderDate expression=${payload.order.date} type=STRING"}
{"description": "Multi-step transformation pipeline combining payloadFactory and enrich mediators to build complex response with data from multiple sources including payload, variables, and inline content", "reply": "sequence name=ComplexTransformSequence payloadFactory media-type=json format { \"transaction\": { \"id\": \"${vars.transactionId}\", \"amount\": ${payload.amount}, \"currency\": \"USD\" } } enrich source type=inline clone=true metadata processedAt ${now()} processor MI-Node-01 target type=body action=child"}
{"description": "PayloadFactory mediator constructing error response payload with standardized structure including error code, message, timestamp, and request correlation ID for API error handling", "reply": "sequence name=ErrorResponseBuilder payloadFactory media-type=json format { \"error\": { \"code\": \"${vars.errorCode}\", \"message\": \"${vars.errorMessage}\", \"timestamp\": \"${formatDateTime(now(), 'yyyy-MM-dd HH:mm:ss')}\", \"correlationId\": \"${vars.correlationId}\", \"path\": \"${props.synapse.REST_URL_POSTFIX}\" } } header name=HTTP_SC value=400 scope=axis2"}
{"description": "Header mediator pattern for CORS configuration adding required headers to enable cross-origin resource sharing including allowed origins, methods, and credentials for browser-based API clients", "reply": "sequence name=CORSHeadersSequence header name=Access-Control-Allow-Origin value=* scope=transport header name=Access-Control-Allow-Methods value=GET, POST, PUT, DELETE, OPTIONS scope=transport header name=Access-Control-Allow-Headers value=Content-Type, Authorization scope=transport header name=Access-Control-Allow-Credentials value=true scope=transport"}
{"description": "Enrich mediator replacing entire message body with content from external variable containing transformed data, useful for cache retrieval or pre-computed response injection", "reply": "sequence name=ReplacePayloadSequence enrich source type=custom clone=true expression=${vars.cachedResponse} target type=body action=replace"}
{"description": "PayloadFactory transforming flat JSON structure into nested hierarchical format with grouping by category and computed fields for business intelligence reporting APIs", "reply": "sequence name=HierarchicalTransform payloadFactory media-type=json format { \"report\": { \"summary\": { \"totalOrders\": ${payload.orderCount}, \"totalRevenue\": ${payload.revenue}, \"averageOrderValue\": ${payload.revenue / payload.orderCount} }, \"breakdown\": { \"category\": \"${payload.category}\", \"region\": \"${payload.region}\" }, \"generatedAt\": \"${formatDateTime(now(), 'yyyy-MM-dd')}\" } }"}
{"description": "Enrich mediator with custom source expression extracting array elements from payload and appending to existing body content for data aggregation patterns", "reply": "sequence name=AppendArrayDataSequence enrich source type=custom clone=true expression=${payload.items} target type=body action=child enrich source type=inline clone=true totalCount ${length(payload.items)} target type=body action=child"}
{"description": "Complete API resource with payloadFactory, header, and variable mediators transforming incoming order request into backend format with added metadata, correlation tracking, and timestamp enrichment", "reply": "api context=/transform name=OrderTransformationAPI resource methods=POST uri-template=/order inSequence variable name=correlationId expression=${headers.X-Correlation-ID} type=STRING variable name=timestamp expression=${now()} type=STRING payloadFactory media-type=json format { \"orderRequest\": { \"orderId\": \"ORD-${vars.timestamp}\", \"customerId\": \"${payload.customer.id}\", \"items\": ${payload.items}, \"totalAmount\": ${payload.total} }, \"metadata\": { \"correlationId\": \"${vars.correlationId}\", \"timestamp\": \"${vars.timestamp}\" } } header name=X-Order-Correlation value=${vars.correlationId} scope=transport respond"}
{"description": "PayloadFactory creating paginated response format with data array, page metadata including current page number, page size, total records, and navigation links for REST API pagination", "reply": "sequence name=PaginationResponseBuilder payloadFactory media-type=json format { \"data\": ${payload.results}, \"pagination\": { \"currentPage\": ${vars.pageNumber}, \"pageSize\": ${vars.pageSize}, \"totalRecords\": ${vars.totalCount}, \"totalPages\": ${ceil(vars.totalCount / vars.pageSize)} }, \"links\": { \"next\": \"/api/items?page=${vars.pageNumber + 1}\", \"prev\": \"/api/items?page=${vars.pageNumber - 1}\" } }"}
{"description": "Header mediator configuration for content negotiation setting response content type based on Accept header with fallback to JSON, including charset and cache control headers", "reply": "sequence name=ContentNegotiationSequence variable name=acceptType expression=${headers.Accept} type=STRING header name=Content-Type value=${vars.acceptType != null ? vars.acceptType : 'application/json'} scope=transport header name=Charset value=UTF-8 scope=transport header name=Cache-Control value=no-cache, no-store, must-revalidate scope=transport"}
{"description": "Advanced enrich mediator pattern extracting nested object from payload, enriching with additional computed fields, and injecting into new target location for complex data restructuring", "reply": "sequence name=ComplexEnrichSequence variable name=customerData expression=${payload.customer} type=JSON enrich source type=inline clone=true enrichedCustomer originalData ${vars.customerData} computedFields fullName ${vars.customerData.firstName} ${vars.customerData.lastName} accountAge ${now() - vars.customerData.createdDate} target type=body action=replace"}
{"description": "PayloadFactory mediator for batch processing response aggregating results from multiple operations with success count, failure count, and detailed item statuses in structured format", "reply": "sequence name=BatchResponseBuilder payloadFactory media-type=json format { \"batchId\": \"${vars.batchId}\", \"summary\": { \"totalItems\": ${vars.totalItems}, \"successCount\": ${vars.successCount}, \"failureCount\": ${vars.failureCount}, \"processingTime\": ${vars.endTime - vars.startTime} }, \"results\": ${vars.batchResults}, \"status\": \"${vars.successCount == vars.totalItems ? 'COMPLETED' : 'PARTIAL'}\" }"}
{"description": "Multi-mediator transformation sequence combining enrich and payloadFactory to extract user authentication data, validate token expiry, and construct authorized request with enriched security context", "reply": "sequence name=AuthTransformSequence variable name=authToken expression=${headers.Authorization} type=STRING variable name=userId expression=${payload.userId} type=STRING enrich source type=inline clone=true securityContext token ${vars.authToken} validUntil ${vars.tokenExpiry} scope read,write target type=body action=child payloadFactory media-type=json format { \"authorizedRequest\": { \"userId\": \"${vars.userId}\", \"requestData\": ${payload.data}, \"security\": ${xpath('//securityContext')} } }"}
{"description": "Comprehensive transformation API combining payloadFactory for response building, header mediators for HTTP status and custom headers, enrich for metadata injection, and variable extraction for audit logging", "reply": "api context=/api name=ComprehensiveTransformAPI resource methods=POST uri-template=/process inSequence variable name=requestId expression=${payload.requestId} type=STRING variable name=requestTime expression=${now()} type=STRING payloadFactory media-type=json format { \"processedRequest\": { \"id\": \"${vars.requestId}\", \"data\": ${payload.data}, \"status\": \"SUCCESS\" } } enrich source type=inline clone=true auditInfo processedAt ${vars.requestTime} processorNode MI-Node-01 target type=body action=child header name=X-Request-ID value=${vars.requestId} scope=transport header name=X-Processing-Time value=${now() - vars.requestTime} scope=transport header name=HTTP_SC value=200 scope=axis2 respond"}
{"description": "Proxy service that receives SOAP requests and forwards them to a backend HTTP endpoint using passthrough transport with basic authentication. Includes WSDL publishing and service parameters for message tracing.", "reply": "proxy name=SimplePassthroughProxy transports=http https startOnLoad=true target inSequence log category=INFO message Processing SOAP request http.post configKey=BackendService relativePath /api/process headers [] requestBodyType XML requestBodyXml {${xpath('$body/node()')}} respond faultSequence log category=ERROR message Error: ${props.synapse.ERROR_MESSAGE} respond publishWSDL uri=http://backend.example.com/service?wsdl parameter name=serviceType proxy"}
{"description": "Proxy service implementing content-based routing pattern that filters incoming JSON messages based on customer type and routes premium customers to priority endpoint while standard customers go to regular processing endpoint.", "reply": "proxy name=ContentBasedRoutingProxy transports=http https startOnLoad=true target inSequence variable name=customerType expression=${payload.customer.type} type=STRING filter xpath=${vars.customerType == 'premium'} then http.post configKey=PriorityEndpoint relativePath /priority headers [] requestBodyType JSON requestBodyJson ${payload} else http.post configKey=StandardEndpoint relativePath /standard headers [] requestBodyType JSON requestBodyJson ${payload} respond"}
{"description": "Simple proxy service that logs incoming requests and forwards to backend endpoint with custom HTTP headers added including correlation ID and timestamp for request tracking.", "reply": "proxy name=HeaderEnrichmentProxy transports=http https startOnLoad=true target inSequence variable name=correlationId expression=${now()} type=STRING http.post configKey=BackendAPI relativePath /process headers [[\"X-Correlation-ID\",\"${vars.correlationId}\"],[\"X-Timestamp\",\"${formatDateTime(now(), 'yyyy-MM-dd HH:mm:ss')}\"]] requestBodyType JSON requestBodyJson ${payload} respond"}
{"description": "Proxy service with payload transformation using payloadFactory mediator to convert incoming JSON request to XML SOAP format before forwarding to legacy SOAP backend service with namespace declarations.", "reply": "proxy name=JSONToSOAPProxy transports=http https startOnLoad=true target inSequence payloadFactory media-type=xml format Envelope Body ProcessRequest customerId ${payload.customerId} amount ${payload.amount} http.post configKey=SOAPBackend relativePath /soap/service headers [[\"Content-Type\",\"text/xml\"]] requestBodyType XML requestBodyXml {${xpath('$body/node()')}} respond"}
{"description": "Proxy service implementing database lookup pattern that queries MySQL database to validate customer credentials before forwarding authenticated requests to protected backend service with error handling.", "reply": "proxy name=DBLookupProxy transports=http https startOnLoad=true target inSequence dblookup connection pool driver com.mysql.jdbc.Driver url jdbc:mysql://localhost:3306/customerdb user dbuser password dbpass123 statement sql SELECT status FROM customers WHERE customer_id = ? parameter expression=${payload.customerId} type=VARCHAR result name=customerStatus column=status filter xpath=${vars.customerStatus == 'active'} then http.post configKey=ProtectedService relativePath /secure headers [] requestBodyType JSON requestBodyJson ${payload} else payloadFactory media-type=json format {\"error\": \"Customer not active\"} respond"}
{"description": "Proxy service with scatter-gather pattern that broadcasts requests to multiple backend services in parallel, aggregates JSON responses, and returns combined result with timeout configuration.", "reply": "proxy name=ScatterGatherProxy transports=http https startOnLoad=true target inSequence scatter-gather parallel-execution=true target=Body result-content-type=JSON aggregation expression=${payload} timeout=5000 sequence http.get configKey=ServiceA relativePath /data headers [] sequence http.get configKey=ServiceB relativePath /info headers [] sequence http.get configKey=ServiceC relativePath /status headers [] respond"}
{"description": "Proxy service with switch mediator implementing protocol routing that examines message content type header and routes to appropriate backend service based on media type with default fallback endpoint.", "reply": "proxy name=ProtocolRoutingProxy transports=http https startOnLoad=true target inSequence variable name=contentType expression=${headers['Content-Type']} type=STRING switch source=${vars.contentType} case regex=application/json http.post configKey=JSONProcessor relativePath /json headers [] requestBodyType JSON requestBodyJson ${payload} case regex=application/xml http.post configKey=XMLProcessor relativePath /xml headers [] requestBodyType XML requestBodyXml {${xpath('$body/node()')}} default http.post configKey=DefaultProcessor relativePath /default headers [] respond"}
{"description": "Proxy service implementing request-response caching pattern using Redis connector to cache backend responses with TTL configuration and cache key based on request parameters for performance optimization.", "reply": "proxy name=CachingProxy transports=http https startOnLoad=true target inSequence variable name=cacheKey expression=${payload.productId} type=STRING redis.get configKey=RedisConfig key ${vars.cacheKey} filter xpath=${exists(vars.redis_get_result)} then payloadFactory media-type=json format ${vars.redis_get_result} else http.get configKey=ProductService relativePath /products/${vars.cacheKey} headers [] variable name=response expression=${payload} type=JSON redis.put configKey=RedisConfig key ${vars.cacheKey} value ${vars.response} expiryTime 3600 respond"}
{"description": "Proxy service with foreach mediator that processes array of order items individually, enriches each item with inventory data from backend service, and aggregates enriched results into final response payload.", "reply": "proxy name=OrderProcessingProxy transports=http https startOnLoad=true target inSequence variable name=enrichedOrders expression=[] type=JSON foreach expression=${payload.orders} sequence variable name=currentItem expression=${payload} type=JSON http.get configKey=InventoryService relativePath /inventory/${vars.currentItem.productId} headers [] variable name=inventoryData expression=${payload} type=JSON payloadFactory media-type=json format {\"orderId\": \"${vars.currentItem.orderId}\", \"productId\": \"${vars.currentItem.productId}\", \"stock\": \"${vars.inventoryData.available}\"} respond"}
{"description": "Proxy service implementing throttling pattern with rate limiting that restricts client requests to maximum threshold per time window and rejects excess requests with HTTP 429 status code.", "reply": "proxy name=ThrottlingProxy transports=http https startOnLoad=true target inSequence throttle id=RequestThrottle policy Policy ThrottleAssertion MaximumCount 100 UnitTime 60000 onAccept http.post configKey=BackendAPI relativePath /process headers [] requestBodyType JSON requestBodyJson ${payload} onReject payloadFactory media-type=json format {\"error\": \"Rate limit exceeded\"} respond"}
{"description": "Basic proxy service that receives HTTP requests and forwards them to backend REST API endpoint with minimal transformation and logging for monitoring purposes.", "reply": "proxy name=BasicForwardProxy transports=http https startOnLoad=true target inSequence log category=INFO message Forwarding request http.post configKey=BackendREST relativePath /api headers [] requestBodyType JSON requestBodyJson ${payload} respond"}
{"description": "Proxy service with WSDL endpoint that exposes SOAP interface and performs header-based authentication by validating API key before routing to secure backend service.", "reply": "proxy name=SecureSOAPProxy transports=http https startOnLoad=true target inSequence variable name=apiKey expression=${headers['X-API-Key']} type=STRING filter xpath=${vars.apiKey == 'valid-key-12345'} then http.post configKey=SecureBackend relativePath /secure headers [] requestBodyType XML requestBodyXml {${xpath('$body/node()')}} else throwError type=AUTH_ERROR errorMessage=Invalid API key respond faultSequence payloadFactory media-type=json format {\"error\": \"${props.synapse.ERROR_MESSAGE}\"} respond publishWSDL uri=file:///wsdl/service.wsdl"}
{"description": "Proxy service that validates incoming JSON payload against required fields and data types before processing, throwing descriptive errors for validation failures with proper fault handling sequence.", "reply": "proxy name=ValidationProxy transports=http https startOnLoad=true target inSequence filter xpath=${exists(payload.userId) and exists(payload.amount)} then filter xpath=${isNumber(payload.amount)} then http.post configKey=ProcessingService relativePath /process headers [] requestBodyType JSON requestBodyJson ${payload} else throwError type=VALIDATION_ERROR errorMessage=Amount must be numeric else throwError type=VALIDATION_ERROR errorMessage=Missing required fields respond faultSequence payloadFactory media-type=json format {\"error\": \"${props.synapse.ERROR_MESSAGE}\"} respond"}
{"description": "Proxy service implementing message enrichment pattern that calls external service to retrieve additional customer details and merges with original request payload using enrich mediator.", "reply": "proxy name=EnrichmentProxy transports=http https startOnLoad=true target inSequence variable name=originalPayload expression=${payload} type=JSON http.get configKey=CustomerService relativePath /customers/${payload.customerId} headers [] variable name=customerDetails expression=${payload} type=JSON payloadFactory media-type=json format {\"orderId\": \"${vars.originalPayload.orderId}\", \"amount\": ${vars.originalPayload.amount}, \"customer\": {\"name\": \"${vars.customerDetails.name}\", \"email\": \"${vars.customerDetails.email}\"}} http.post configKey=OrderService relativePath /orders headers [] requestBodyType JSON requestBodyJson ${payload} respond"}
{"description": "Proxy service with transaction mediator that ensures atomic database operations by performing database insert and update within distributed transaction boundary with rollback on failure.", "reply": "proxy name=TransactionalProxy transports=http https startOnLoad=true target inSequence transaction action=new dbreport connection pool driver com.mysql.jdbc.Driver url jdbc:mysql://localhost:3306/orderdb user dbuser password dbpass123 statement sql INSERT INTO orders (order_id, customer_id, amount) VALUES (?, ?, ?) parameter expression=${payload.orderId} type=VARCHAR parameter expression=${payload.customerId} type=VARCHAR parameter expression=${payload.amount} type=DOUBLE dbreport connection pool driver com.mysql.jdbc.Driver url jdbc:mysql://localhost:3306/orderdb user dbuser password dbpass123 statement sql UPDATE inventory SET quantity = quantity - 1 WHERE product_id = ? parameter expression=${payload.productId} type=VARCHAR transaction action=commit respond"}
{"description": "Simple proxy service that accepts requests on HTTP transport, logs message at INFO level, and forwards to backend endpoint with respond mediator for synchronous response.", "reply": "proxy name=SimpleLogProxy transports=http startOnLoad=true target inSequence log category=INFO message Request received http.post configKey=Backend relativePath /api headers [] requestBodyType JSON requestBodyJson ${payload} respond"}
{"description": "Proxy service with dynamic endpoint routing that reads target backend URL from registry based on environment variable and routes requests accordingly with failover configuration.", "reply": "proxy name=DynamicRoutingProxy transports=http https startOnLoad=true target inSequence variable name=environment expression=${configs.deployment_env} type=STRING variable name=targetURL expression=${registry('conf:/endpoints/' + vars.environment + '/backend.json').url} type=STRING log category=INFO message Routing to ${vars.targetURL} http.post configKey=DynamicBackend relativePath /process headers [] requestBodyType JSON requestBodyJson ${payload} respond parameter name=serviceType proxy"}
{"description": "Proxy service that transforms XML SOAP response from backend into JSON format using XSLT mediator with stylesheet transformation and content type header modification for REST clients.", "reply": "proxy name=SOAPToJSONProxy transports=http https startOnLoad=true target inSequence http.post configKey=SOAPService relativePath /soap headers [[\"Content-Type\",\"text/xml\"]] requestBodyType XML requestBodyXml {${xpath('$body/node()')}} xslt key=conf:/transformations/soap-to-json.xslt header name=Content-Type value=application/json respond"}
{"description": "Proxy service with dataServiceCall mediator that invokes WSO2 Data Service to execute complex SQL query with multiple input parameters and processes tabular result set.", "reply": "proxy name=DataServiceProxy transports=http https startOnLoad=true target inSequence dataServiceCall serviceName=CustomerDataService operations operation name=getCustomerOrders param name=customerId value=${payload.customerId} param name=startDate value=${payload.startDate} param name=endDate value=${payload.endDate} source type=inline target type=body log category=INFO message Data service result: ${payload} respond"}
{"description": "Proxy service implementing compensating transaction pattern that executes business logic and triggers rollback sequence with compensating actions when errors occur during processing.", "reply": "proxy name=CompensationProxy transports=http https startOnLoad=true target inSequence variable name=bookingId expression=${payload.bookingId} type=STRING http.post configKey=PaymentService relativePath /charge headers [] requestBodyType JSON requestBodyJson ${payload} variable name=paymentStatus expression=${payload.status} type=STRING http.post configKey=InventoryService relativePath /reserve headers [] requestBodyType JSON requestBodyJson {\"bookingId\": \"${vars.bookingId}\"} respond faultSequence log category=ERROR message Executing compensation for booking ${vars.bookingId} http.post configKey=PaymentService relativePath /refund headers [] requestBodyType JSON requestBodyJson {\"bookingId\": \"${vars.bookingId}\"} payloadFactory media-type=json format {\"error\": \"Transaction failed and compensated\"} respond"}
{"description": "REST API with single GET resource that returns a static JSON payload using payloadFactory mediator. Simple health check endpoint at /api/health context with inline JSON response.", "reply": "api context=/api/health name=HealthCheckAPI resource methods=GET uri-template=/ inSequence payloadFactory media-type=json format {\"status\":\"UP\",\"timestamp\":\"${now()}\"} respond"}
{"description": "REST API with POST method accepting JSON payload. Uses variable mediator to extract user data from request body and logs the username before responding with success message.", "reply": "api context=/users name=UserAPI resource methods=POST uri-template=/ inSequence variable name=username expression=${payload.name} type=STRING log category=INFO message User created: ${vars.username} payloadFactory media-type=json format {\"message\":\"User created successfully\",\"user\":\"${vars.username}\"} respond"}
{"description": "REST API with URI template path parameter for user ID. GET method extracts userId from path parameters and constructs response payload dynamically using Synapse expressions.", "reply": "api context=/users name=GetUserAPI resource methods=GET uri-template=/{userId} inSequence variable name=userId expression=${params.pathParams.userId} type=STRING payloadFactory media-type=json format {\"userId\":\"${vars.userId}\",\"action\":\"retrieve\"} respond"}
{"description": "REST API supporting multiple HTTP methods on same resource. GET retrieves data, POST creates new record, PUT updates existing record. Uses filter mediator to route based on REST_METHOD property.", "reply": "api context=/products name=ProductAPI resource methods=GET POST PUT uri-template=/{id} inSequence filter xpath=${props.synapse.REST_METHOD == 'GET'} then payloadFactory media-type=json format {\"action\":\"retrieve\",\"id\":\"${params.pathParams.id}\"} else payloadFactory media-type=json format {\"action\":\"modify\",\"id\":\"${params.pathParams.id}\"} respond"}
{"description": "REST API with DELETE method for resource removal. Extracts resource ID from path parameter, logs deletion action with INFO category, and returns confirmation response using payloadFactory.", "reply": "api context=/orders name=DeleteOrderAPI resource methods=DELETE uri-template=/{orderId} inSequence variable name=orderId expression=${params.pathParams.orderId} type=STRING log category=INFO message Deleting order: ${vars.orderId} payloadFactory media-type=json format {\"deleted\":true,\"orderId\":\"${vars.orderId}\"} respond"}
{"description": "REST API with query parameter handling. GET method extracts status and limit query parameters using Synapse expressions, constructs filtered response payload dynamically.", "reply": "api context=/orders name=QueryOrdersAPI resource methods=GET uri-template=/ inSequence variable name=status expression=${params.queryParams.status} type=STRING variable name=limit expression=${params.queryParams.limit} type=STRING payloadFactory media-type=json format {\"filter\":{\"status\":\"${vars.status}\",\"limit\":\"${vars.limit}\"}} respond"}
{"description": "REST API with PATCH method for partial resource updates. Accepts JSON payload, extracts update fields using variable mediator, validates existence of required field, and responds with updated status.", "reply": "api context=/customers name=PatchCustomerAPI resource methods=PATCH uri-template=/{customerId} inSequence variable name=customerId expression=${params.pathParams.customerId} type=STRING variable name=email expression=${payload.email} type=STRING filter xpath=${exists(payload.email)} then payloadFactory media-type=json format {\"updated\":true,\"customerId\":\"${vars.customerId}\",\"email\":\"${vars.email}\"} else payloadFactory media-type=json format {\"error\":\"Email field required\"} respond"}
{"description": "REST API with multiple resources under single context. Separate resources for listing all items with GET and creating new item with POST. Each resource has distinct URI template and processing logic.", "reply": "api context=/inventory name=InventoryAPI resource methods=GET uri-template=/items inSequence payloadFactory media-type=json format {\"items\":[],\"count\":0} respond resource methods=POST uri-template=/items inSequence variable name=itemName expression=${payload.name} type=STRING payloadFactory media-type=json format {\"created\":true,\"item\":\"${vars.itemName}\"} respond"}
{"description": "REST API implementing content negotiation by checking Accept header. Uses filter mediator to determine response format, returns JSON or XML based on client preference with appropriate media-type in payloadFactory.", "reply": "api context=/data name=ContentNegotiationAPI resource methods=GET uri-template=/ inSequence variable name=acceptHeader expression=${headers.Accept} type=STRING filter xpath=${vars.acceptHeader == 'application/json'} then payloadFactory media-type=json format {\"format\":\"json\",\"data\":\"content\"} else payloadFactory media-type=xml format <response><format>xml</format></response> respond"}
{"description": "REST API with nested URI template capturing multiple path parameters. GET method extracts category and productId, validates parameters using filter mediator, constructs hierarchical response payload with extracted values.", "reply": "api context=/catalog name=CatalogAPI resource methods=GET uri-template=/{category}/products/{productId} inSequence variable name=category expression=${params.pathParams.category} type=STRING variable name=productId expression=${params.pathParams.productId} type=STRING filter xpath=${exists(params.pathParams.category)} then payloadFactory media-type=json format {\"category\":\"${vars.category}\",\"productId\":\"${vars.productId}\"} else payloadFactory media-type=json format {\"error\":\"Invalid path\"} respond"}
{"description": "REST API with PUT method for complete resource replacement. Validates required fields in request payload using filter mediator, extracts multiple data fields with variable mediators, constructs comprehensive update response.", "reply": "api context=/employees name=UpdateEmployeeAPI resource methods=PUT uri-template=/{empId} inSequence variable name=empId expression=${params.pathParams.empId} type=STRING variable name=name expression=${payload.name} type=STRING variable name=department expression=${payload.department} type=STRING filter xpath=${exists(payload.name) and exists(payload.department)} then payloadFactory media-type=json format {\"updated\":true,\"empId\":\"${vars.empId}\",\"name\":\"${vars.name}\",\"department\":\"${vars.department}\"} else payloadFactory media-type=json format {\"error\":\"Missing required fields\"} respond"}
{"description": "REST API with switch mediator for routing based on path parameter value. Multiple case statements handle different resource types, default case provides fallback response. Demonstrates conditional routing pattern.", "reply": "api context=/resources name=ResourceRouterAPI resource methods=GET uri-template=/{type} inSequence variable name=resourceType expression=${params.pathParams.type} type=STRING switch source=${vars.resourceType} case regex=users payloadFactory media-type=json format {\"type\":\"users\",\"data\":[]} case regex=products payloadFactory media-type=json format {\"type\":\"products\",\"data\":[]} default payloadFactory media-type=json format {\"error\":\"Unknown resource type\"} respond"}
{"description": "REST API combining path and query parameters for filtered resource retrieval. GET method extracts userId from path and multiple query filters, performs conditional validation, constructs detailed response with all extracted parameters.", "reply": "api context=/reports name=ReportAPI resource methods=GET uri-template=/{userId}/transactions inSequence variable name=userId expression=${params.pathParams.userId} type=STRING variable name=startDate expression=${params.queryParams.startDate} type=STRING variable name=endDate expression=${params.queryParams.endDate} type=STRING variable name=type expression=${params.queryParams.type} type=STRING filter xpath=${exists(params.queryParams.startDate)} then payloadFactory media-type=json format {\"userId\":\"${vars.userId}\",\"filters\":{\"start\":\"${vars.startDate}\",\"end\":\"${vars.endDate}\",\"type\":\"${vars.type}\"}} else payloadFactory media-type=json format {\"error\":\"Date range required\"} respond"}
{"description": "REST API with POST method calling backend HTTP endpoint using HTTP connector. Extracts request data, forwards to external service with dynamic path and headers, processes response before returning to client.", "reply": "api context=/orders name=CreateOrderAPI resource methods=POST uri-template=/ inSequence variable name=customerId expression=${payload.customerId} type=STRING variable name=amount expression=${payload.amount} type=STRING log category=INFO message Creating order for customer: ${vars.customerId} payloadFactory media-type=json format {\"customerId\":\"${vars.customerId}\",\"amount\":${vars.amount},\"status\":\"pending\"} respond faultSequence payloadFactory media-type=json format {\"error\":\"Order creation failed\"} respond"}
{"description": "REST API implementing OPTIONS method for CORS preflight handling. Returns allowed HTTP methods, headers, and origin. Uses header mediator to set CORS response headers dynamically based on request.", "reply": "api context=/api name=CorsAPI resource methods=OPTIONS uri-template=/* inSequence header name=Access-Control-Allow-Origin value=* scope=transport header name=Access-Control-Allow-Methods value=GET,POST,PUT,DELETE,PATCH scope=transport header name=Access-Control-Allow-Headers value=Content-Type,Authorization scope=transport payloadFactory media-type=json format {\"message\":\"CORS preflight success\"} respond"}
{"description": "REST API with resource supporting multiple HTTP methods including GET, POST, DELETE. Uses switch mediator on REST_METHOD property to route to different processing sequences, each handling method-specific logic with distinct response payloads.", "reply": "api context=/tasks name=TaskAPI resource methods=GET POST DELETE uri-template=/{taskId} inSequence variable name=taskId expression=${params.pathParams.taskId} type=STRING switch source=${props.synapse.REST_METHOD} case regex=GET payloadFactory media-type=json format {\"action\":\"retrieve\",\"taskId\":\"${vars.taskId}\"} case regex=POST payloadFactory media-type=json format {\"action\":\"create\",\"taskId\":\"${vars.taskId}\"} case regex=DELETE payloadFactory media-type=json format {\"action\":\"delete\",\"taskId\":\"${vars.taskId}\"} default payloadFactory media-type=json format {\"error\":\"Method not allowed\"} respond"}
{"description": "REST API with POST method performing payload transformation and validation. Extracts nested JSON fields using Synapse expressions, validates mandatory fields with filter mediator, enriches payload with timestamp and status before responding.", "reply": "api context=/registrations name=RegistrationAPI resource methods=POST uri-template=/ inSequence variable name=email expression=${payload.user.email} type=STRING variable name=name expression=${payload.user.name} type=STRING variable name=phone expression=${payload.user.phone} type=STRING filter xpath=${exists(payload.user.email) and exists(payload.user.name)} then variable name=timestamp expression=${now()} type=STRING payloadFactory media-type=json format {\"registered\":true,\"user\":{\"email\":\"${vars.email}\",\"name\":\"${vars.name}\",\"phone\":\"${vars.phone}\"},\"timestamp\":\"${vars.timestamp}\",\"status\":\"active\"} else payloadFactory media-type=json format {\"error\":\"Email and name are required fields\"} respond"}
{"description": "REST API implementing pagination with query parameters. GET method extracts page and pageSize from query params, validates numeric values, constructs response with pagination metadata including total count and current page details.", "reply": "api context=/items name=PaginatedItemsAPI resource methods=GET uri-template=/ inSequence variable name=page expression=${params.queryParams.page} type=STRING variable name=pageSize expression=${params.queryParams.pageSize} type=STRING filter xpath=${exists(params.queryParams.page)} then variable name=offset expression=${integer(vars.page) * integer(vars.pageSize)} type=INTEGER payloadFactory media-type=json format {\"items\":[],\"pagination\":{\"page\":${vars.page},\"pageSize\":${vars.pageSize},\"offset\":${vars.offset},\"total\":100}} else payloadFactory media-type=json format {\"items\":[],\"pagination\":{\"page\":1,\"pageSize\":10,\"total\":100}} respond"}
{"description": "Complex REST API with multiple resources implementing CRUD operations. Separate resources for list, create, retrieve, update, delete with appropriate HTTP methods. Each resource extracts parameters, performs validation, logs actions, and constructs method-specific responses with error handling.", "reply": "api context=/products name=ProductCRUDAPI resource methods=GET uri-template=/ inSequence variable name=category expression=${params.queryParams.category} type=STRING log category=INFO message Listing products, category: ${vars.category} payloadFactory media-type=json format {\"products\":[],\"category\":\"${vars.category}\"} respond resource methods=POST uri-template=/ inSequence variable name=name expression=${payload.name} type=STRING variable name=price expression=${payload.price} type=STRING filter xpath=${exists(payload.name)} then payloadFactory media-type=json format {\"created\":true,\"id\":\"P123\",\"name\":\"${vars.name}\",\"price\":${vars.price}} else payloadFactory media-type=json format {\"error\":\"Name required\"} respond resource methods=GET PUT DELETE uri-template=/{productId} inSequence variable name=productId expression=${params.pathParams.productId} type=STRING switch source=${props.synapse.REST_METHOD} case regex=GET payloadFactory media-type=json format {\"product\":{\"id\":\"${vars.productId}\",\"name\":\"Sample\"}} case regex=PUT payloadFactory media-type=json format {\"updated\":true,\"id\":\"${vars.productId}\"} case regex=DELETE payloadFactory media-type=json format {\"deleted\":true,\"id\":\"${vars.productId}\"} respond"}
{"description": "REST API with advanced query parameter filtering and sorting. GET method extracts multiple filter criteria including search term, status, sortBy, and order. Constructs complex query object in response with validation of allowed sort fields and direction.", "reply": "api context=/search name=SearchAPI resource methods=GET uri-template=/ inSequence variable name=query expression=${params.queryParams.q} type=STRING variable name=status expression=${params.queryParams.status} type=STRING variable name=sortBy expression=${params.queryParams.sortBy} type=STRING variable name=order expression=${params.queryParams.order} type=STRING variable name=limit expression=${params.queryParams.limit} type=STRING filter xpath=${exists(params.queryParams.q)} then variable name=sortField expression=${vars.sortBy == null ? 'createdAt' : vars.sortBy} type=STRING variable name=sortOrder expression=${vars.order == null ? 'desc' : vars.order} type=STRING payloadFactory media-type=json format {\"results\":[],\"query\":\"${vars.query}\",\"filters\":{\"status\":\"${vars.status}\"},\"sort\":{\"field\":\"${vars.sortField}\",\"order\":\"${vars.sortOrder}\"},\"limit\":${vars.limit}} else payloadFactory media-type=json format {\"error\":\"Search query required\"} respond"}
{"description": "Scheduled task that triggers every 5 minutes using a simple trigger to execute a sequence that logs system health status and sends notification to monitoring endpoint using HTTP connector", "reply": "task class=org.apache.synapse.startup.tasks.MessageInjector group=synapse.simple.quartz name=HealthCheckTask trigger interval=300 property name=injectTo value=sequence property name=sequenceName value=HealthCheckSequence"}
{"description": "Cron-based scheduled task executing daily at midnight to trigger batch processing sequence for data synchronization with external CRM system using custom message format and interval counting", "reply": "task class=org.apache.synapse.startup.tasks.MessageInjector group=synapse.simple.quartz name=DailyCRMSyncTask trigger cron=0 0 0 * * ? property name=message syncRequest timestamp daily property name=injectTo value=sequence property name=sequenceName value=CRMBatchSyncSequence"}
{"description": "Simple trigger task running every 30 seconds to inject message into proxy service for real-time inventory level monitoring and alert generation with JSON payload format", "reply": "task class=org.apache.synapse.startup.tasks.MessageInjector group=synapse.simple.quartz name=InventoryMonitorTask trigger interval=30 property name=message inventoryCheck checkType realtime property name=injectTo value=proxy property name=proxyName value=InventoryMonitorProxy"}
{"description": "Hourly cron scheduled task at 15 minutes past each hour triggering API endpoint for automated report generation and distribution to stakeholders via sequence execution", "reply": "task class=org.apache.synapse.startup.tasks.MessageInjector group=synapse.simple.quartz name=HourlyReportTask trigger cron=0 15 * * * ? property name=injectTo value=sequence property name=sequenceName value=ReportGenerationSequence"}
{"description": "Interval-based task executing every 10 minutes to trigger database cleanup sequence removing expired session records and temporary data using dbreport mediator with transaction management", "reply": "task class=org.apache.synapse.startup.tasks.MessageInjector group=synapse.simple.quartz name=DBCleanupTask trigger interval=600 property name=message cleanupRequest action purgeExpired property name=injectTo value=sequence property name=sequenceName value=DatabaseCleanupSequence"}
{"description": "Weekly scheduled task using cron expression to execute every Monday at 8 AM for triggering comprehensive system backup sequence with file operations and archival processing", "reply": "task class=org.apache.synapse.startup.tasks.MessageInjector group=synapse.simple.quartz name=WeeklyBackupTask trigger cron=0 0 8 ? * MON property name=message backupRequest type weekly schedule monday property name=injectTo value=sequence property name=sequenceName value=SystemBackupSequence"}
{"description": "Scheduled task running every 2 hours using simple trigger to synchronize customer data between internal database and external cloud service via sequence with HTTP connector and data transformation", "reply": "task class=org.apache.synapse.startup.tasks.MessageInjector group=synapse.simple.quartz name=CustomerSyncTask trigger interval=7200 property name=message syncRequest entity customer direction bidirectional property name=injectTo value=sequence property name=sequenceName value=CustomerDataSyncSequence"}
{"description": "Cron scheduled task executing on first day of every month at 1 AM for monthly billing aggregation and invoice generation triggering sequence with database operations and email notifications", "reply": "task class=org.apache.synapse.startup.tasks.MessageInjector group=synapse.simple.quartz name=MonthlyBillingTask trigger cron=0 0 1 1 * ? property name=message billingRequest period monthly generateInvoices true property name=injectTo value=sequence property name=sequenceName value=MonthlyBillingSequence"}
{"description": "Simple trigger task with 15-minute interval injecting messages to API for periodic cache refresh and content delivery network synchronization with REST endpoint invocation pattern", "reply": "task class=org.apache.synapse.startup.tasks.MessageInjector group=synapse.simple.quartz name=CacheRefreshTask trigger interval=900 property name=message refreshRequest cacheType CDN property name=injectTo value=sequence property name=sequenceName value=CacheRefreshSequence"}
{"description": "Daily cron task at 3 AM triggering data warehouse ETL process via sequence including database lookup, data transformation with payloadFactory, and batch insert operations for analytics", "reply": "task class=org.apache.synapse.startup.tasks.MessageInjector group=synapse.simple.quartz name=DailyETLTask trigger cron=0 0 3 * * ? property name=message etlRequest source operational target warehouse processType incremental property name=injectTo value=sequence property name=sequenceName value=ETLProcessSequence"}
{"description": "Scheduled task with 5-minute simple trigger for order processing queue monitoring injecting message to sequence that checks pending orders, validates inventory, and updates order status via database operations", "reply": "task class=org.apache.synapse.startup.tasks.MessageInjector group=synapse.simple.quartz name=OrderQueueTask trigger interval=300 property name=message queueCheck queueName pendingOrders action processNext property name=injectTo value=sequence property name=sequenceName value=OrderProcessingSequence"}
{"description": "Cron expression task running every weekday at 6 PM to trigger end-of-day reconciliation process with sequence executing financial calculations, transaction validation, and discrepancy reporting via multiple mediators", "reply": "task class=org.apache.synapse.startup.tasks.MessageInjector group=synapse.simple.quartz name=EODReconciliationTask trigger cron=0 0 18 ? * MON-FRI property name=message reconciliationRequest period daily includeTransactions true property name=injectTo value=sequence property name=sequenceName value=ReconciliationSequence"}
{"description": "Interval-based task executing every hour to trigger API rate limit reset sequence updating Redis cache counters and synchronizing rate limiting metadata across distributed nodes using connector operations", "reply": "task class=org.apache.synapse.startup.tasks.MessageInjector group=synapse.simple.quartz name=RateLimitResetTask trigger interval=3600 property name=message resetRequest resource rateLimits action resetCounters property name=injectTo value=sequence property name=sequenceName value=RateLimitResetSequence"}
{"description": "Scheduled task with cron trigger every 6 hours for automated security token rotation injecting message to sequence that generates new tokens, updates vault secrets, and notifies dependent services via HTTP calls", "reply": "task class=org.apache.synapse.startup.tasks.MessageInjector group=synapse.simple.quartz name=TokenRotationTask trigger cron=0 0 0/6 * * ? property name=message rotationRequest tokenType serviceAccount rotationType automatic property name=injectTo value=sequence property name=sequenceName value=TokenRotationSequence"}
{"description": "Simple trigger task every 20 minutes for log aggregation and analysis triggering sequence with file connector operations to collect logs, transform with XSLT, and send aggregated data to monitoring dashboard", "reply": "task class=org.apache.synapse.startup.tasks.MessageInjector group=synapse.simple.quartz name=LogAggregationTask trigger interval=1200 property name=message aggregationRequest logType application timeWindow 20 property name=injectTo value=sequence property name=sequenceName value=LogAggregationSequence"}
{"description": "Cron scheduled task on 15th of each month at 10 AM for subscription renewal processing executing sequence with database queries, payment gateway integration, email connector for notifications, and audit logging", "reply": "task class=org.apache.synapse.startup.tasks.MessageInjector group=synapse.simple.quartz name=SubscriptionRenewalTask trigger cron=0 0 10 15 * ? property name=message renewalRequest billingCycle monthly autoRenew true property name=injectTo value=sequence property name=sequenceName value=SubscriptionRenewalSequence"}
{"description": "Interval task every 45 seconds triggering real-time stock price update sequence with HTTP connector to fetch market data, enrich mediator to add metadata, cache update, and broadcast to WebSocket subscribers", "reply": "task class=org.apache.synapse.startup.tasks.MessageInjector group=synapse.simple.quartz name=StockPriceUpdateTask trigger interval=45 property name=message priceUpdate symbols AAPL,GOOGL,MSFT frequency realtime property name=injectTo value=sequence property name=sequenceName value=StockPriceUpdateSequence"}
{"description": "Daily cron task at 2 AM for automated database backup triggering sequence with dblookup for metadata, script mediator for compression logic, file connector for storage, and email notification on completion", "reply": "task class=org.apache.synapse.startup.tasks.MessageInjector group=synapse.simple.quartz name=DatabaseBackupTask trigger cron=0 0 2 * * ? property name=message backupRequest databases production,staging compression true retention 30 property name=injectTo value=sequence property name=sequenceName value=DatabaseBackupSequence"}
{"description": "Scheduled task with 10-minute interval for API health check executing sequence with scatter-gather to ping multiple endpoints, aggregate responses, filter for failures, log warnings, and update service registry status", "reply": "task class=org.apache.synapse.startup.tasks.MessageInjector group=synapse.simple.quartz name=APIHealthCheckTask trigger interval=600 property name=message healthCheck endpoints payment,inventory,shipping,notification timeout 5000 property name=injectTo value=sequence property name=sequenceName value=APIHealthCheckSequence"}
{"description": "Cron task every Sunday at midnight for weekly sales report generation triggering complex sequence with database aggregation queries, data transformation using datamapper, PDF generation, cloud storage upload, and stakeholder email distribution", "reply": "task class=org.apache.synapse.startup.tasks.MessageInjector group=synapse.simple.quartz name=WeeklySalesReportTask trigger cron=0 0 0 ? * SUN property name=message reportRequest reportType weeklySales format PDF distribution email,storage recipients management@company.com property name=injectTo value=sequence property name=sequenceName value=WeeklySalesReportSequence"}
{"description": "Named sequence for logging incoming requests with HTTP method, URI, and timestamp using INFO category. Implements reusable logging pattern for request auditing across multiple API resources.", "reply": "sequence name=RequestLoggerSequence log category=INFO message Request received - Method: ${props.synapse.REST_METHOD}, URI: ${props.synapse.REST_URL_POSTFIX}, Timestamp: ${now()}"}
{"description": "Local entry storing HTTP connector initialization configuration for external product service with basic authentication, 30 second timeout, and retry policy with 3 attempts on 500 errors.", "reply": "localEntry key=ProductServiceConn http.init connectionType https baseUrl https://api.products.example.com authType Basic Auth basicCredentialsUsername apiuser basicCredentialsPassword Prod@2024Pass timeoutDuration 30 retryErrorCodes 500,502,503 retryCount 3 retryDelay 2 name ProductServiceConn"}
{"description": "Sequence template with mandatory firstName and lastName parameters. Constructs welcome message using function parameters and logs to INFO category for customer greeting workflows.", "reply": "template name=CustomerWelcomeTemplate parameter isMandatory=true name=firstName parameter isMandatory=true name=lastName sequence log category=INFO message Welcome ${params.functionParams.firstName} ${params.functionParams.lastName} to our service"}
{"description": "Error handling sequence with custom fault logging that captures error code, message, and detail. Constructs JSON error response payload with status false and timestamp before sending respond mediator.", "reply": "sequence name=CustomErrorHandler log category=ERROR message Error occurred - Code: ${props.synapse.ERROR_CODE}, Message: ${props.synapse.ERROR_MESSAGE}, Detail: ${props.synapse.ERROR_DETAIL} payloadFactory media-type=json format {\"status\":false,\"error\":\"${props.synapse.ERROR_MESSAGE}\",\"timestamp\":\"${now()}\"} respond"}
{"description": "Reusable sequence for payload validation checking required fields userId and amount exist. Uses filter mediator with Synapse expressions and throws PAYLOAD_ERROR if validation fails.", "reply": "sequence name=PayloadValidationSequence filter xpath=${exists(payload.userId) and exists(payload.amount)} then log category=INFO message Payload validation successful else throwError type=PAYLOAD_ERROR errorMessage=Required fields userId and amount are missing"}
{"description": "Local entry storing database connection pool configuration for MySQL order management system with driver, JDBC URL, credentials, and connection pool properties for transaction processing.", "reply": "localEntry key=OrderDBConfig dblookup connection pool driver com.mysql.jdbc.Driver url jdbc:mysql://localhost:3306/orderdb user dbadmin password DbPass@2024 property name=maxActive value=50 property name=maxIdle value=10 property name=minIdle value=5"}
{"description": "Template for enriching payload with correlation ID and processing timestamp. Accepts correlationId parameter and adds metadata fields using enrich mediator before continuing message flow.", "reply": "template name=EnrichWithMetadataTemplate parameter isMandatory=true name=correlationId sequence variable name=correlationId expression=${params.functionParams.correlationId} type=STRING variable name=timestamp expression=${now()} type=STRING enrich source type=inline clone=true metadata correlationId ${vars.correlationId} timestamp ${vars.timestamp} target type=body action=child"}
{"description": "Modular sequence for authentication token validation. Extracts Authorization header, validates bearer token format using filter mediator, and sets authenticated user variable for downstream processing.", "reply": "sequence name=TokenValidationSequence variable name=authHeader expression=${headers['Authorization']} type=STRING filter xpath=${startsWith(vars.authHeader, 'Bearer ')} then variable name=token expression=${subString(vars.authHeader, 7)} type=STRING variable name=isAuthenticated value=true type=STRING log category=INFO message Token validation successful else throwError type=AUTH_ERROR errorMessage=Invalid authorization header format"}
{"description": "Sequence template implementing retry logic pattern with attempts and delay parameters. Uses loopback mediator for retry mechanism and logs retry attempts for monitoring failed service calls.", "reply": "template name=RetryTemplate parameter isMandatory=true name=maxRetries parameter isMandatory=true name=delaySeconds sequence variable name=retryCount expression=${params.functionParams.maxRetries} type=INTEGER variable name=delay expression=${params.functionParams.delaySeconds} type=INTEGER log category=INFO message Retry configured - Max attempts: ${vars.retryCount}, Delay: ${vars.delay}s"}
{"description": "Named sequence for response transformation converting backend XML to JSON format. Uses payloadFactory mediator to construct standardized JSON response structure with status and data fields.", "reply": "sequence name=XMLtoJSONTransformSequence variable name=responseData expression=${xpath('//result/text()')} type=STRING payloadFactory media-type=json format {\"status\":\"success\",\"data\":\"${vars.responseData}\",\"timestamp\":\"${now()}\"} log category=INFO message Response transformed to JSON"}
{"description": "Local entry for Redis connector configuration with host localhost, port 6379, connection timeout, and pool settings. Stores reusable cache connection parameters for session management integration.", "reply": "localEntry key=RedisConfig redis.init redisHost localhost redisPort 6379 connectionTimeout 5000 maxConnections 20 maxIdleConnections 5 name RedisConfig"}
{"description": "Complex sequence implementing scatter-gather pattern for parallel service calls. Aggregates responses from inventory and pricing services using scatter-gather mediator with JSON result aggregation and timeout handling.", "reply": "sequence name=ParallelAggregationSequence scatter-gather parallel-execution=true target=Body result-content-type=JSON aggregation expression=${payload} timeout=10000 sequence http.get configKey=InventoryServiceConn relativePath /api/stock/${vars.productId} headers [] sequence http.get configKey=PricingServiceConn relativePath /api/price/${vars.productId} headers []"}
{"description": "Template for conditional routing based on message priority parameter. Uses switch mediator to route high priority to express queue and normal to standard queue with appropriate logging.", "reply": "template name=PriorityRoutingTemplate parameter isMandatory=true name=priority sequence variable name=msgPriority expression=${params.functionParams.priority} type=STRING switch source=${vars.msgPriority} case regex=high log category=INFO message Routing to express queue sequence key=ExpressQueueSequence default log category=INFO message Routing to standard queue sequence key=StandardQueueSequence"}
{"description": "Reusable database lookup sequence querying customer details by ID. Uses dblookup mediator with parameterized SQL, stores results in variables, and logs retrieved customer information for downstream processing.", "reply": "sequence name=CustomerLookupSequence dblookup connection pool driver com.mysql.jdbc.Driver url jdbc:mysql://localhost:3306/customerdb user appuser password App@Pass123 statement sql SELECT name, email FROM customers WHERE id = ? parameter expression=${vars.customerId} type=INTEGER result name=customerName column=name result name=customerEmail column=email log category=INFO message Customer retrieved: ${vars.customerName}"}
{"description": "Local entry storing API key and endpoint constants for third-party payment gateway integration. Defines baseUrl, merchantId, and apiKey as reusable configuration values for payment processing sequences.", "reply": "localEntry key=PaymentGatewayConstants constants baseUrl https://api.paymentgateway.com/v2 merchantId MERCH_987654 apiKey pk_live_AbCdEf123456789XyZ timeout 15000 currency USD"}
{"description": "Sequence implementing request throttling check using filter mediator. Validates request count against threshold, logs warning for exceeded limits, and throws error to enforce rate limiting policy.", "reply": "sequence name=RateLimitCheckSequence variable name=requestCount expression=${vars.currentRequests} type=INTEGER variable name=maxRequests value=100 type=INTEGER filter xpath=${vars.requestCount > vars.maxRequests} then log category=WARN message Rate limit exceeded: ${vars.requestCount} requests throwError type=THROTTLE_ERROR errorMessage=Rate limit of ${vars.maxRequests} requests exceeded else log category=INFO message Request count within limits: ${vars.requestCount}"}
{"description": "Template for data enrichment calling external service with userId parameter. Performs HTTP GET request, extracts user profile data, enriches payload with additional fields, and returns augmented message.", "reply": "template name=UserEnrichmentTemplate parameter isMandatory=true name=userId sequence variable name=userId expression=${params.functionParams.userId} type=STRING http.get configKey=UserServiceConn relativePath /api/users/${vars.userId} headers [[\"Accept\",\"application/json\"]] variable name=userName expression=${payload.name} type=STRING variable name=userEmail expression=${payload.email} type=STRING log category=INFO message User enriched: ${vars.userName}"}
{"description": "Named sequence for audit logging writing transaction records to database. Uses dbreport mediator with INSERT statement capturing transactionId, userId, action, and timestamp for compliance tracking.", "reply": "sequence name=AuditLogSequence variable name=transactionId expression=${vars.txnId} type=STRING variable name=userId expression=${vars.userId} type=STRING variable name=action expression=${vars.action} type=STRING dbreport connection pool driver com.mysql.jdbc.Driver url jdbc:mysql://localhost:3306/auditdb user audituser password Audit@2024 statement sql INSERT INTO audit_log (transaction_id, user_id, action, timestamp) VALUES (?, ?, ?, NOW()) parameter expression=${vars.transactionId} type=VARCHAR parameter expression=${vars.userId} type=VARCHAR parameter expression=${vars.action} type=VARCHAR"}
{"description": "Comprehensive integration sequence orchestrating multi-step order processing workflow. Validates payload, enriches with customer data via template call, performs inventory check, creates order record, and returns confirmation response.", "reply": "sequence name=OrderProcessingWorkflow sequence key=PayloadValidationSequence variable name=orderId expression=${payload.orderId} type=STRING variable name=customerId expression=${payload.customerId} type=STRING call-template target=UserEnrichmentTemplate with-param name=userId value={${vars.customerId}} http.post configKey=InventoryServiceConn relativePath /api/inventory/check headers [[\"Content-Type\",\"application/json\"]] requestBodyType JSON requestBodyJson ${payload} sequence key=AuditLogSequence payloadFactory media-type=json format {\"orderId\":\"${vars.orderId}\",\"status\":\"confirmed\",\"message\":\"Order processed successfully\"} respond"}
{"description": "Local entry containing SMTP email server configuration for notification sequences. Stores host, port, authentication credentials, and SSL settings for reusable email integration across multiple notification workflows.", "reply": "localEntry key=EmailServerConfig email.init host smtp.gmail.com port 587 username notifications@company.com password EmailPass@2024 enableStartTLS true enableSSL false fromAddress noreply@company.com name EmailServerConfig"}
{"description": "Log mediator configuration using INFO category to output a simple message with string concatenation of user name from JSON payload using Synapse expression syntax", "reply": "log category=INFO message User authentication request received for ${payload.user.name}"}
{"description": "Variable mediator storing string value for API endpoint URL configuration that can be referenced in subsequent mediators using vars namespace", "reply": "variable name=apiEndpoint value=https://api.example.com/v1/users type=STRING"}
{"description": "Variable mediator extracting integer user ID from JSON payload using Synapse expression and storing as INTEGER type for numeric operations", "reply": "variable name=userId expression=${payload.user.id} type=INTEGER"}
{"description": "Log mediator with ERROR category logging fault details including error code and error message from synapse properties for debugging failed transactions", "reply": "log category=ERROR message Transaction failed - Code: ${props.synapse.ERROR_CODE}, Message: ${props.synapse.ERROR_MESSAGE}"}
{"description": "Variable mediator storing complete JSON object from payload user data section as JSON type for downstream processing and transformation", "reply": "variable name=userDataObject expression=${payload.user.data} type=JSON"}
{"description": "Log mediator with DEBUG category showing request method from synapse properties and content type header for API request tracing", "reply": "log category=DEBUG message Request Method: ${props.synapse.REST_METHOD}, Content-Type: ${headers[\"Content-Type\"]}"}
{"description": "API resource using variable mediator to extract query parameter value and log mediator to output the parameter for request validation and tracking", "reply": "api context=/users name=UserAPI resource methods=GET uri-template=?status={status} inSequence variable name=userStatus expression=${params.queryParams.status} type=STRING log category=INFO message Fetching users with status: ${vars.userStatus}"}
{"description": "Sequence storing configuration value, extracting email from payload, logging with WARN category, and using conditional expression to validate email existence", "reply": "sequence name=EmailValidationSeq variable name=defaultEmail value=noreply@example.com type=STRING variable name=userEmail expression=${payload.contact.email} type=STRING log category=WARN message Email validation: ${exists(vars.userEmail) ? vars.userEmail : vars.defaultEmail}"}
{"description": "Variable mediator calculating total price by multiplying quantity and unit price from JSON payload using arithmetic expression syntax with integer conversion", "reply": "variable name=totalPrice expression=${integer(payload.quantity) * integer(payload.unitPrice)} type=INTEGER"}
{"description": "Log mediator with INFO category displaying transaction details including transaction ID from payload and timestamp using now function in Synapse expression", "reply": "log category=INFO message Transaction ${payload.transactionId} processed at ${formatDateTime(now(), \"yyyy-MM-dd HH:mm:ss\")}"}
{"description": "Variable mediator using ternary operator to set status based on age validation from payload, checking if user is adult or minor for authorization logic", "reply": "variable name=userStatus expression=${payload.age >= 18 ? 'ADULT' : 'MINOR'} type=STRING"}
{"description": "Sequence storing authentication token from header, user role from payload, logging with INFO category, and validating admin access using logical AND expression", "reply": "sequence name=AuthValidationSeq variable name=authToken expression=${headers.Authorization} type=STRING variable name=userRole expression=${payload.user.role} type=STRING log category=INFO message Admin access: ${exists(vars.authToken) and vars.userRole == 'ADMIN'}"}
{"description": "API resource extracting path parameter customer ID, storing order count from payload, logging transaction with DEBUG level, and computing eligibility status using comparison expression", "reply": "api context=/orders name=OrderAPI resource methods=POST uri-template=/{customerId} inSequence variable name=customerId expression=${params.pathParams.customerId} type=STRING variable name=orderCount expression=${payload.totalOrders} type=INTEGER log category=DEBUG message Customer ${vars.customerId} has ${vars.orderCount} orders variable name=isPremium expression=${vars.orderCount > 10} type=BOOLEAN"}
{"description": "Variable mediator converting string amount to double type, calculating discount percentage, and storing final discounted price using nested arithmetic operations in Synapse expression", "reply": "sequence name=DiscountCalculation variable name=originalAmount expression=${float(payload.price)} type=DOUBLE variable name=discountRate value=0.15 type=DOUBLE variable name=finalAmount expression=${vars.originalAmount - (vars.originalAmount * vars.discountRate)} type=DOUBLE"}
{"description": "Log mediator with FATAL category for critical system errors, displaying error details from synapse properties, exception message, and request URI for incident management", "reply": "log category=FATAL message CRITICAL ERROR - Code: ${props.synapse.ERROR_CODE}, Exception: ${props.synapse.ERROR_EXCEPTION}, URI: ${props.synapse.REST_URL_POSTFIX}"}
{"description": "Variable mediator using string manipulation functions to extract username substring, convert to uppercase, and concatenate with domain suffix for email generation", "reply": "variable name=generatedEmail expression=${toUpper(subString(payload.username, 0, 3)) + '@company.com'} type=STRING"}
{"description": "Sequence implementing JSONPath filtering to extract high-value orders, storing result array, logging count with INFO level, and validating minimum order threshold using length function", "reply": "sequence name=FilterHighValueOrders variable name=highValueOrders expression=${payload.orders[?(@.amount > 1000)]} type=JSON log category=INFO message Found ${length(vars.highValueOrders)} high-value orders exceeding threshold variable name=meetsMinimum expression=${length(vars.highValueOrders) >= 5} type=BOOLEAN"}
{"description": "API resource with comprehensive request logging using multiple variables to capture client IP from axis2 properties, request timestamp, payload size using length function, and transaction correlation ID from header for audit trail", "reply": "api context=/transactions name=TransactionAPI resource methods=POST inSequence variable name=clientIP expression=${props.axis2.REMOTE_ADDR} type=STRING variable name=requestTime expression=${formatDateTime(now(), 'yyyy-MM-dd HH:mm:ss')} type=STRING variable name=payloadSize expression=${length(string(payload))} type=INTEGER variable name=correlationId expression=${headers['X-Correlation-ID']} type=STRING log category=INFO message Request from ${vars.clientIP} at ${vars.requestTime}, Size: ${vars.payloadSize} bytes, CorrelationID: ${vars.correlationId}"}
{"description": "Complex sequence extracting nested customer data from payload, computing loyalty points with bonus multiplier, formatting account balance with round function, and logging comprehensive customer profile with DEBUG category including all calculated metrics", "reply": "sequence name=CustomerProfileProcessing variable name=customerId expression=${payload.customer.profile.id} type=STRING variable name=purchaseAmount expression=${float(payload.transaction.amount)} type=DOUBLE variable name=basePoints expression=${ceil(vars.purchaseAmount * 0.1)} type=INTEGER variable name=bonusMultiplier expression=${payload.customer.tier == 'GOLD' ? 1.5 : 1.0} type=DOUBLE variable name=totalPoints expression=${integer(vars.basePoints * vars.bonusMultiplier)} type=INTEGER variable name=accountBalance expression=${round(vars.purchaseAmount, 2)} type=DOUBLE log category=DEBUG message Customer ${vars.customerId}: Amount=${vars.accountBalance}, Points=${vars.totalPoints}, Tier=${payload.customer.tier}"}
{"description": "Fault sequence with comprehensive error handling extracting error details from synapse properties, storing error timestamp, formatting error response JSON structure, logging with ERROR category, and preparing detailed fault message with correlation ID from transport headers for troubleshooting", "reply": "sequence name=ErrorHandlerSequence variable name=errorCode expression=${props.synapse.ERROR_CODE} type=STRING variable name=errorMessage expression=${props.synapse.ERROR_MESSAGE} type=STRING variable name=errorTimestamp expression=${formatDateTime(now(), 'yyyy-MM-dd HH:mm:ss.SSS')} type=STRING variable name=correlationId expression=${headers['X-Request-ID']} type=STRING log category=ERROR message Error occurred - Code: ${vars.errorCode}, Message: ${vars.errorMessage}, Time: ${vars.errorTimestamp}, RequestID: ${vars.correlationId} payloadFactory media-type=json format {\"error\":{\"code\":\"${vars.errorCode}\",\"message\":\"${vars.errorMessage}\",\"timestamp\":\"${vars.errorTimestamp}\"}}"}
